---
phase: 03-mcp-server-claude-code
plan: 03
type: execute
wave: 2
depends_on: [03-01, 03-02]
files_modified:
  - mcp/src/jarvis_mcp/tools/__init__.py
  - mcp/src/jarvis_mcp/tools/search.py
  - mcp/src/jarvis_mcp/server.py
autonomous: true

must_haves:
  truths:
    - "search_memory tool is registered with FastMCP server"
    - "Tool accepts query, limit, and sources parameters"
    - "Tool calls POST /api/search/ on Jarvis server"
    - "Results are formatted as readable text for LLM consumption"
    - "Tool calls are logged in audit trail"
  artifacts:
    - path: "mcp/src/jarvis_mcp/tools/search.py"
      provides: "search_memory MCP tool implementation"
      contains: "@mcp.tool()"
    - path: "mcp/src/jarvis_mcp/tools/__init__.py"
      provides: "Tools module initialization"
  key_links:
    - from: "mcp/src/jarvis_mcp/tools/search.py"
      to: "/api/search/"
      via: "httpx POST request"
      pattern: "client.post.*api/search"
    - from: "mcp/src/jarvis_mcp/tools/search.py"
      to: "mcp/src/jarvis_mcp/audit.py"
      via: "log_mcp_call import"
      pattern: "from.*audit.*import.*log_mcp_call"
---

<objective>
Implement search_memory MCP tool

Purpose: Create the primary memory search tool that Claude Code users will invoke to query all captured content. This fulfills MCP-02 requirement.

Output: Functional search_memory tool registered with the MCP server
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-mcp-server-claude-code/03-RESEARCH.md
@server/src/jarvis_server/search/schemas.py
@server/src/jarvis_server/api/search.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tools module and search_memory implementation</name>
  <files>
    mcp/src/jarvis_mcp/tools/__init__.py
    mcp/src/jarvis_mcp/tools/search.py
  </files>
  <action>
Create the tools/ directory with search_memory implementation.

mcp/src/jarvis_mcp/tools/__init__.py:
- Empty file (package marker)

mcp/src/jarvis_mcp/tools/search.py:
- Import from typing: Annotated
- Import from pydantic: Field
- Import time for duration tracking
- Import from mcp.exceptions: ToolError
- Import from jarvis_mcp.server: mcp (the FastMCP instance)
- Import from jarvis_mcp.client: get_client
- Import from jarvis_mcp.validators: validate_search_query
- Import from jarvis_mcp.audit: log_mcp_call
- Import structlog and get logger

@mcp.tool() decorator on async function:

async def search_memory(
    query: Annotated[str, Field(
        min_length=1,
        max_length=1000,
        description="Natural language search query for finding information in your memory"
    )],
    limit: Annotated[int, Field(
        default=10,
        ge=1,
        le=50,
        description="Maximum number of results to return"
    )] = 10,
    sources: Annotated[list[str] | None, Field(
        default=None,
        description="Filter by source: screen, chatgpt, claude, grok"
    )] = None,
) -> str:

Docstring (used by FastMCP to generate tool description):
"""Search all Jarvis memory sources using semantic and keyword matching.

Finds relevant screen captures, chat conversations, and documents
across all imported sources. Results are ranked by relevance using
hybrid search (semantic understanding + keyword matching).

Examples:
- "meetings about project alpha last week"
- "code review feedback from yesterday"
- "discussion about API design in Claude"
"""

Implementation:
1. start_time = time.monotonic()
2. Try block:
   a. sanitized_query = validate_search_query(query)
   b. client = await get_client()
   c. response = await client.post("/api/search/", json={
        "query": sanitized_query,
        "limit": limit,
        "sources": sources,
      })
   d. response.raise_for_status()
   e. data = response.json()
   f. Format results as readable text:
      - If no results: "No matching memories found."
      - Otherwise: "Found {N} relevant memories:\n\n" + formatted list
      - Each result: "{i}. [{source}] {date}\n   {text_preview}"
   g. Call log_mcp_call with success=True
   h. Return result_text

3. Except httpx.HTTPStatusError:
   - Log failure via log_mcp_call
   - Raise ToolError("Memory search temporarily unavailable")

4. Except Exception:
   - logger.exception("search_memory_failed")
   - Log failure via log_mcp_call
   - Raise ToolError("Search failed unexpectedly")
  </action>
  <verify>
python -c "
from jarvis_mcp.tools.search import search_memory
from jarvis_mcp.server import mcp

# Verify tool is registered
tools = mcp.list_tools()
tool_names = [t.name for t in tools]
assert 'search_memory' in tool_names, f'search_memory not in {tool_names}'

print('search_memory tool registered successfully')
"
  </verify>
  <done>search_memory function created and registered with FastMCP</done>
</task>

<task type="auto">
  <name>Task 2: Update server.py to import tools</name>
  <files>mcp/src/jarvis_mcp/server.py</files>
  <action>
Modify server.py to import the search tool module AFTER creating the FastMCP instance.

The import order is critical:
1. Configure structlog (already done)
2. Create FastMCP instance (already done)
3. Import tools modules (NEW - after mcp is created)

Add after the mcp = FastMCP(...) line:
# Register tools by importing (decorators register with mcp instance)
from jarvis_mcp.tools import search  # noqa: F401 E402

The noqa comments suppress:
- F401: imported but unused (import is for side effect of registration)
- E402: module level import not at top of file (required for FastMCP pattern)
  </action>
  <verify>
python -c "
from jarvis_mcp.server import mcp

# Verify search_memory is available
tools = mcp.list_tools()
assert any(t.name == 'search_memory' for t in tools), 'search_memory not registered'

print('Server has search_memory tool')
"
  </verify>
  <done>Server imports tools module, search_memory is registered</done>
</task>

</tasks>

<verification>
1. python -c "from jarvis_mcp.tools.search import search_memory" works
2. Tool is registered: mcp.list_tools() includes search_memory
3. Tool has correct parameters (query, limit, sources)
4. Tool has descriptive docstring
</verification>

<success_criteria>
- search_memory tool registered with FastMCP
- Tool accepts query (required), limit (default 10), sources (optional filter)
- Tool calls POST /api/search/ on Jarvis server
- Results formatted as numbered list with source and date
- Empty results return helpful message
- HTTP errors raise ToolError (not raw exception)
- All calls logged to audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-server-claude-code/03-03-SUMMARY.md`
</output>
