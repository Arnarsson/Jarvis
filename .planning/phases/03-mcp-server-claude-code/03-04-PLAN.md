---
phase: 03-mcp-server-claude-code
plan: 04
type: execute
wave: 2
depends_on: [03-01, 03-02]
files_modified:
  - mcp/src/jarvis_mcp/tools/catchup.py
  - mcp/src/jarvis_mcp/server.py
autonomous: true

must_haves:
  truths:
    - "catch_me_up tool is registered with FastMCP server"
    - "Tool accepts topic and days parameters"
    - "Tool filters search by date range (last N days)"
    - "Results are grouped by date for context recovery"
    - "Tool calls are logged in audit trail"
  artifacts:
    - path: "mcp/src/jarvis_mcp/tools/catchup.py"
      provides: "catch_me_up MCP tool implementation"
      contains: "@mcp.tool()"
  key_links:
    - from: "mcp/src/jarvis_mcp/tools/catchup.py"
      to: "/api/search/"
      via: "httpx POST with date filter"
      pattern: "start_date.*end_date"
    - from: "mcp/src/jarvis_mcp/tools/catchup.py"
      to: "mcp/src/jarvis_mcp/audit.py"
      via: "log_mcp_call import"
      pattern: "from.*audit.*import.*log_mcp_call"
---

<objective>
Implement catch_me_up MCP tool

Purpose: Create the context recovery tool that helps users get caught up on any project or topic by summarizing recent activity. This fulfills MCP-03 requirement.

Output: Functional catch_me_up tool registered with the MCP server
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-mcp-server-claude-code/03-RESEARCH.md
@server/src/jarvis_server/search/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create catch_me_up tool implementation</name>
  <files>mcp/src/jarvis_mcp/tools/catchup.py</files>
  <action>
Create mcp/src/jarvis_mcp/tools/catchup.py with the catch_me_up tool.

Imports:
- from typing import Annotated
- from pydantic import Field
- from datetime import datetime, timedelta, timezone
- import time
- from mcp.exceptions import ToolError
- import structlog
- from jarvis_mcp.server import mcp
- from jarvis_mcp.client import get_client
- from jarvis_mcp.validators import validate_topic
- from jarvis_mcp.audit import log_mcp_call

logger = structlog.get_logger(__name__)

@mcp.tool() decorator on async function:

async def catch_me_up(
    topic: Annotated[str, Field(
        min_length=1,
        max_length=500,
        description="Project name, topic, or area to get caught up on"
    )],
    days: Annotated[int, Field(
        default=7,
        ge=1,
        le=30,
        description="How many days back to look"
    )] = 7,
) -> str:

Docstring:
"""Get a context summary for a topic or project.

Reviews recent activity across all memory sources related to the
specified topic, then provides a chronological summary to help you
get back up to speed quickly.

Examples:
- "project alpha" - summarize recent project activity
- "API redesign" - catch up on API discussions
- "team standup" - review recent standup notes
"""

Implementation:
1. start_time = time.monotonic()
2. Try block:
   a. sanitized_topic = validate_topic(topic)
   b. Calculate date range:
      - end_date = datetime.now(tz=timezone.utc)
      - start_date = end_date - timedelta(days=days)
   c. client = await get_client()
   d. response = await client.post("/api/search/", json={
        "query": sanitized_topic,
        "limit": 20,
        "start_date": start_date.isoformat(),
        "end_date": end_date.isoformat(),
      })
   e. response.raise_for_status()
   f. data = response.json()
   g. Format results grouped by date:
      - If no results: "No activity found for '{topic}' in the last {days} days."
      - Otherwise group by date (timestamp[:10]):
        by_date: dict[str, list] = {}
        for r in results:
            date_key = r["timestamp"][:10]
            by_date.setdefault(date_key, []).append(r)
      - Format as:
        "Context recovery for '{topic}' (last {days} days):\n\n"
        "Found {N} relevant items across {M} days.\n\n"
        Then for each date (sorted descending, max 5 dates):
        "**{date}**:\n"
        "  - [{source}] {text_preview[:100]}" (max 3 items per date)
   h. Call log_mcp_call with success=True, result_summary includes counts
   i. Return result_text

3. Except httpx.HTTPStatusError:
   - Log failure via log_mcp_call
   - Raise ToolError("Context recovery temporarily unavailable")

4. Except Exception:
   - logger.exception("catch_me_up_failed")
   - Log failure via log_mcp_call
   - Raise ToolError("Context recovery failed")
  </action>
  <verify>
python -c "
from jarvis_mcp.tools.catchup import catch_me_up
from jarvis_mcp.server import mcp

# Verify tool exists in module
print('catch_me_up function imported')
"
  </verify>
  <done>catch_me_up function created with date filtering and grouped output</done>
</task>

<task type="auto">
  <name>Task 2: Update server.py to import catchup tool</name>
  <files>mcp/src/jarvis_mcp/server.py</files>
  <action>
Add the catchup module import to server.py alongside the search import.

Update the imports section after mcp = FastMCP(...):

# Register tools by importing (decorators register with mcp instance)
from jarvis_mcp.tools import search  # noqa: F401 E402
from jarvis_mcp.tools import catchup  # noqa: F401 E402
  </action>
  <verify>
python -c "
from jarvis_mcp.server import mcp

# Verify both tools are registered
tools = mcp.list_tools()
tool_names = [t.name for t in tools]
assert 'search_memory' in tool_names, 'search_memory missing'
assert 'catch_me_up' in tool_names, 'catch_me_up missing'

print(f'Server has {len(tools)} tools: {tool_names}')
"
  </verify>
  <done>Server imports both tools modules, catch_me_up is registered</done>
</task>

</tasks>

<verification>
1. python -c "from jarvis_mcp.tools.catchup import catch_me_up" works
2. Tool is registered: mcp.list_tools() includes catch_me_up
3. Tool has correct parameters (topic, days)
4. Tool has descriptive docstring
5. Both search_memory and catch_me_up registered with server
</verification>

<success_criteria>
- catch_me_up tool registered with FastMCP
- Tool accepts topic (required), days (default 7, max 30)
- Tool searches with date filter (start_date = now - days)
- Results grouped by date for chronological context
- Empty results return helpful message
- HTTP errors raise ToolError (not raw exception)
- All calls logged to audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-server-claude-code/03-04-SUMMARY.md`
</output>
