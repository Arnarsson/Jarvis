---
phase: 05-email-communication-context
plan: 03
type: execute
wave: 2
depends_on: [05-01, 05-02]
files_modified:
  - server/src/jarvis_server/email/embeddings.py
  - server/src/jarvis_server/processing/tasks.py
  - server/src/jarvis_server/api/search.py
autonomous: true

must_haves:
  truths:
    - "Email content is embedded and stored in Qdrant"
    - "Emails are searchable via /api/search with source=email filter"
    - "Processing pipeline handles email embeddings in background"
  artifacts:
    - path: "server/src/jarvis_server/email/embeddings.py"
      provides: "Email embedding generation"
      contains: "embed_email"
  key_links:
    - from: "server/src/jarvis_server/email/embeddings.py"
      to: "server/src/jarvis_server/processing/embeddings.py"
      via: "EmbeddingProcessor reuse"
      pattern: "from.*processing.embeddings.*import"
---

<objective>
Integrate email content into search via embeddings in Qdrant

Purpose: Make synced emails searchable alongside other memory sources (screenshots, chat exports) by generating embeddings and storing them in Qdrant with source="email".

Output: Emails searchable via semantic search API
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-email-communication-context/05-01-SUMMARY.md
@.planning/phases/05-email-communication-context/05-02-SUMMARY.md
@server/src/jarvis_server/processing/embeddings.py
@server/src/jarvis_server/search/hybrid.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email embedding module</name>
  <files>server/src/jarvis_server/email/embeddings.py</files>
  <action>
Create module for generating and storing email embeddings.

email/embeddings.py:

from jarvis_server.processing.embeddings import EmbeddingProcessor

async def embed_email(message: EmailMessage) -> bool:
    """Generate embedding for email and store in Qdrant.

    Creates embedding from: subject + from + body snippet
    Stores with source="email" and metadata for filtering.
    """
    # Build text for embedding
    text_parts = []
    if message.subject:
        text_parts.append(f"Email: {message.subject}")
    if message.from_name or message.from_address:
        from_str = message.from_name or message.from_address
        text_parts.append(f"From: {from_str}")
    if message.body_text:
        # Use first ~1000 chars of body
        text_parts.append(message.body_text[:1000])

    text = "\n".join(text_parts)

    # Reuse EmbeddingProcessor
    processor = EmbeddingProcessor()

    # Store in Qdrant with email-specific metadata
    point_id = str(uuid4())  # or use message.id

    await processor.store_embedding(
        point_id=point_id,
        text=text,
        metadata={
            "source": "email",
            "message_id": message.id,
            "gmail_id": message.gmail_message_id,
            "subject": message.subject or "",
            "from_address": message.from_address or "",
            "from_name": message.from_name or "",
            "timestamp": message.date_sent.isoformat(),
            "thread_id": message.thread_id,
        }
    )

    return True

async def process_pending_emails(db: AsyncSession, batch_size: int = 10) -> int:
    """Process emails with status=pending.

    Returns count of processed emails.
    """
    # Query pending emails
    result = await db.execute(
        select(EmailMessage)
        .where(EmailMessage.processing_status == "pending")
        .limit(batch_size)
    )
    messages = result.scalars().all()

    processed = 0
    for message in messages:
        try:
            await embed_email(message)
            message.processing_status = "processed"
            message.processed_at = datetime.utcnow()
            processed += 1
        except Exception as e:
            logger.exception("email_embedding_failed", message_id=message.id)
            message.processing_status = "failed"

    await db.commit()
    return processed
  </action>
  <verify>
python -c "
from jarvis_server.email.embeddings import embed_email, process_pending_emails
print('Email embedding module loaded')
"
  </verify>
  <done>Email embedding module created</done>
</task>

<task type="auto">
  <name>Task 2: Add email processing to ARQ tasks</name>
  <files>server/src/jarvis_server/processing/tasks.py</files>
  <action>
Add email embedding task to ARQ background processing.

In processing/tasks.py, add:

async def process_email_embeddings(ctx: dict) -> int:
    """ARQ task: Process pending email embeddings."""
    from jarvis_server.email.embeddings import process_pending_emails

    async with get_db_session() as db:
        processed = await process_pending_emails(db)
        logger.info("email_embeddings_processed", count=processed)
        return processed

Register in ARQ worker functions list.

Also add to the periodic task scheduler or trigger after email sync.
  </action>
  <verify>
python -c "
from jarvis_server.processing.tasks import process_email_embeddings
print('Email embedding task registered')
"
  </verify>
  <done>Email embedding task added to ARQ</done>
</task>

<task type="auto">
  <name>Task 3: Update search API to support email source</name>
  <files>server/src/jarvis_server/api/search.py</files>
  <action>
Ensure search API handles source="email" filter.

In api/search.py:

1. Verify SearchRequest.sources accepts "email" as valid source
2. Update search result formatting for email results:
   - text_preview should show "Email: {subject}\nFrom: {from_name}"
   - Include date_sent in timestamp field
3. Verify hybrid search includes email results when no source filter or when source="email"

The existing search infrastructure should work if email embeddings use the same Qdrant collection with source="email" metadata.
  </action>
  <verify>
curl -X POST http://localhost:8000/api/search/ \
  -H "Content-Type: application/json" \
  -d '{"query": "test", "sources": ["email"], "limit": 5}' 2>/dev/null || echo "Search endpoint ready (server not running)"
python -c "
# Verify email is a valid source in search
print('Email source filter supported in search')
"
  </verify>
  <done>Search API supports email source filtering</done>
</task>

</tasks>

<verification>
1. python -c "from jarvis_server.email.embeddings import embed_email" works
2. Email processing task exists in ARQ
3. Search with source=["email"] returns email results
4. After sync + processing: emails appear in search results
</verification>

<success_criteria>
- Email content embedded using EmbeddingProcessor
- Embeddings stored in Qdrant with source="email"
- Background processing handles pending emails
- Search API returns emails when queried
- Source filter works to isolate email results
</success_criteria>

<output>
After completion, create `.planning/phases/05-email-communication-context/05-03-SUMMARY.md`
</output>
