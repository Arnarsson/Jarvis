---
phase: 05-email-communication-context
plan: 04
type: execute
wave: 3
depends_on: [05-01, 05-02, 05-03]
files_modified:
  - server/src/jarvis_server/email/search.py
  - server/src/jarvis_server/meetings/briefs.py
autonomous: true

must_haves:
  truths:
    - "Pre-meeting briefs include relevant email context"
    - "Emails are found by attendee email addresses and meeting topics"
    - "Brief prompt includes email highlights section"
  artifacts:
    - path: "server/src/jarvis_server/email/search.py"
      provides: "Email search for meeting context"
      contains: "search_emails_for_meeting"
  key_links:
    - from: "server/src/jarvis_server/meetings/briefs.py"
      to: "server/src/jarvis_server/email/search.py"
      via: "search_emails_for_meeting import"
      pattern: "from.*email.search.*import"
---

<objective>
Enrich pre-meeting briefs with relevant email context

Purpose: When generating pre-meeting briefs, search emails for relevant threads involving meeting attendees or discussion topics. Add email highlights to the brief output.

Output: Pre-meeting briefs that include email context
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-email-communication-context/05-02-SUMMARY.md
@.planning/phases/05-email-communication-context/05-03-SUMMARY.md
@server/src/jarvis_server/meetings/briefs.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email search for meeting context</name>
  <files>server/src/jarvis_server/email/search.py</files>
  <action>
Create module for searching emails relevant to meetings.

email/search.py:

async def search_emails_for_meeting(
    db: AsyncSession,
    attendee_emails: list[str],
    meeting_topic: str,
    lookback_days: int = 30,
    max_results: int = 5,
) -> list[EmailMessage]:
    """Search for emails relevant to a meeting.

    Finds emails by:
    1. From/To matching attendee email addresses
    2. Subject/body matching meeting topic (semantic search)

    Returns most relevant emails for context.
    """
    results = []

    # 1. Search by attendee addresses
    if attendee_emails:
        cutoff = datetime.utcnow() - timedelta(days=lookback_days)

        # Build OR conditions for each attendee email
        addr_conditions = []
        for addr in attendee_emails[:10]:  # Limit to avoid huge queries
            addr_conditions.append(EmailMessage.from_address.ilike(f"%{addr}%"))
            addr_conditions.append(EmailMessage.to_addresses.ilike(f"%{addr}%"))

        query = (
            select(EmailMessage)
            .where(
                EmailMessage.date_sent >= cutoff,
                or_(*addr_conditions)
            )
            .order_by(EmailMessage.date_sent.desc())
            .limit(max_results)
        )

        result = await db.execute(query)
        results.extend(result.scalars().all())

    # 2. Semantic search by topic if we have one
    if meeting_topic and len(meeting_topic) > 3:
        # Use Qdrant semantic search for topic matching
        from jarvis_server.search.hybrid import hybrid_search

        search_results = await hybrid_search(
            query=meeting_topic,
            sources=["email"],
            limit=max_results,
            start_date=datetime.utcnow() - timedelta(days=lookback_days),
        )

        # Fetch full email records for results
        for sr in search_results:
            if sr.source == "email" and sr.metadata.get("message_id"):
                email = await db.get(EmailMessage, sr.metadata["message_id"])
                if email and email not in results:
                    results.append(email)

    # Deduplicate and sort by date
    seen_ids = set()
    unique_results = []
    for email in results:
        if email.id not in seen_ids:
            seen_ids.add(email.id)
            unique_results.append(email)

    unique_results.sort(key=lambda e: e.date_sent, reverse=True)
    return unique_results[:max_results]


def format_email_context(emails: list[EmailMessage]) -> str:
    """Format emails for brief context section."""
    if not emails:
        return "No relevant recent emails found."

    lines = ["Recent related emails:"]
    for email in emails:
        date_str = email.date_sent.strftime("%m/%d") if email.date_sent else "?"
        from_str = email.from_name or email.from_address or "Unknown"
        subject = email.subject or "No subject"
        snippet = (email.snippet or "")[:100]

        lines.append(f"- [{date_str}] {from_str}: {subject}")
        if snippet:
            lines.append(f"  \"{snippet}...\"")

    return "\n".join(lines)
  </action>
  <verify>
python -c "
from jarvis_server.email.search import search_emails_for_meeting, format_email_context
print('Email search module loaded')
"
  </verify>
  <done>Email search for meeting context created</done>
</task>

<task type="auto">
  <name>Task 2: Update brief generation to include email context</name>
  <files>server/src/jarvis_server/meetings/briefs.py</files>
  <action>
Update BRIEF_PROMPT to include email context section.

1. Add {email_context} placeholder to BRIEF_PROMPT:

BRIEF_PROMPT = """You are preparing a brief for an upcoming meeting.

Meeting: {title}
Time: {time}
Attendees: {attendees}
Description: {description}

## Context from Memory
{context}

## Email Highlights
{email_context}

Generate a concise pre-meeting brief with:
1. **Purpose**: What this meeting is likely about
2. **Key Points**: Important context from memory and emails
3. **People**: Brief on each attendee if context available
4. **Suggested Topics**: What might be discussed

Keep the brief focused and actionable. If there's limited context available, acknowledge that and focus on what can be inferred from the meeting details.

Format with markdown headers and bullet points for easy scanning."""

2. Update gather_meeting_context to return both memory and email context:

async def gather_meeting_context(
    event: CalendarEvent,
    db: AsyncSession,
    max_results: int = 10
) -> tuple[str, str]:
    """Search memory and email for context relevant to the meeting.

    Returns:
        Tuple of (memory_context, email_context)
    """
    # ... existing memory search code ...

    # Extract attendee email addresses
    attendee_emails = []
    if event.attendees_json:
        try:
            attendees = json.loads(event.attendees_json)
            for attendee in attendees[:10]:
                email_addr = attendee.get('email')
                if email_addr:
                    attendee_emails.append(email_addr)
        except (json.JSONDecodeError, TypeError):
            pass

    # Search for relevant emails
    from jarvis_server.email.search import search_emails_for_meeting, format_email_context

    email_results = await search_emails_for_meeting(
        db=db,
        attendee_emails=attendee_emails,
        meeting_topic=event.summary or "",
        lookback_days=30,
        max_results=5,
    )
    email_context = format_email_context(email_results)

    return memory_context, email_context

3. Update generate_pre_meeting_brief to use both contexts.
  </action>
  <verify>
python -c "
from jarvis_server.meetings.briefs import BRIEF_PROMPT, gather_meeting_context
assert 'email_context' in BRIEF_PROMPT or 'email' in BRIEF_PROMPT.lower(), 'Email context not in prompt'
print('Brief generation updated with email context')
"
  </verify>
  <done>Brief generation updated to include email context</done>
</task>

</tasks>

<verification>
1. python -c "from jarvis_server.email.search import search_emails_for_meeting" works
2. BRIEF_PROMPT includes email context placeholder
3. gather_meeting_context returns both memory and email context
4. Generated briefs include email highlights section
</verification>

<success_criteria>
- Email search finds messages by attendee email addresses
- Email search finds messages by meeting topic (semantic)
- Brief prompt includes email context section
- Pre-meeting briefs show relevant email threads
- Brief quality improves with email context
</success_criteria>

<output>
After completion, create `.planning/phases/05-email-communication-context/05-04-SUMMARY.md`
</output>
