---
phase: 02-searchable-memory-rag-core
plan: 08
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - server/src/jarvis_server/api/timeline.py
  - server/src/jarvis_server/api/__init__.py
  - server/src/jarvis_server/main.py
autonomous: true

must_haves:
  truths:
    - "User can browse captures by date"
    - "Timeline returns captures with thumbnails and metadata"
    - "Results are paginated for efficient loading"
  artifacts:
    - path: "server/src/jarvis_server/api/timeline.py"
      provides: "Timeline API endpoint"
      exports: ["router"]
  key_links:
    - from: "server/src/jarvis_server/api/timeline.py"
      to: "server/src/jarvis_server/db/models.py"
      via: "Capture query"
      pattern: "select.*Capture"
---

<objective>
Create timeline browsing API for visual history of captures.

Purpose: Enable users to browse their capture history chronologically, see what was captured on specific dates, and navigate to specific captures.

Output: Timeline API endpoint with cursor-based pagination, date filtering, and capture metadata including thumbnail paths.
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-searchable-memory-rag-core/02-RESEARCH.md

# Database models
@server/src/jarvis_server/db/models.py

# Existing API structure
@server/src/jarvis_server/api/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create timeline API schemas and endpoint</name>
  <files>server/src/jarvis_server/api/timeline.py</files>
  <action>
Create timeline API with cursor-based pagination.

**server/src/jarvis_server/api/timeline.py:**
```python
"""Timeline API for browsing capture history."""
import logging
from datetime import datetime, date
from typing import Optional

from fastapi import APIRouter, Depends, Query
from pydantic import BaseModel, Field
from sqlalchemy import func, select, and_
from sqlalchemy.ext.asyncio import AsyncSession

from ..db.session import get_db
from ..db.models import Capture

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/timeline", tags=["timeline"])


class TimelineCapture(BaseModel):
    """A capture in the timeline."""

    id: str
    timestamp: datetime
    filepath: str
    width: int
    height: int
    monitor_index: int
    has_ocr: bool = Field(description="Whether OCR text has been extracted")
    text_preview: Optional[str] = Field(default=None, max_length=200)


class TimelineResponse(BaseModel):
    """Timeline response with pagination."""

    captures: list[TimelineCapture]
    total: int
    next_cursor: Optional[str] = Field(
        default=None,
        description="Cursor for next page (ISO timestamp)"
    )
    has_more: bool


class DaySummary(BaseModel):
    """Summary of captures for a single day."""

    date: date
    count: int
    first_capture: datetime
    last_capture: datetime


@router.get("/", response_model=TimelineResponse)
async def get_timeline(
    limit: int = Query(default=50, ge=1, le=200),
    cursor: Optional[str] = Query(default=None, description="ISO timestamp cursor"),
    start_date: Optional[date] = Query(default=None),
    end_date: Optional[date] = Query(default=None),
    db: AsyncSession = Depends(get_db),
) -> TimelineResponse:
    """Get captures for timeline browsing.

    Returns captures in reverse chronological order (newest first).
    Uses cursor-based pagination for efficient navigation.

    Query params:
    - limit: Number of captures to return (1-200, default 50)
    - cursor: Timestamp to start from (for pagination)
    - start_date: Filter by start date
    - end_date: Filter by end date
    """
    # Build query
    conditions = []

    if cursor:
        try:
            cursor_dt = datetime.fromisoformat(cursor)
            conditions.append(Capture.timestamp < cursor_dt)
        except ValueError:
            pass

    if start_date:
        conditions.append(Capture.timestamp >= datetime.combine(start_date, datetime.min.time()))

    if end_date:
        conditions.append(Capture.timestamp <= datetime.combine(end_date, datetime.max.time()))

    # Query captures
    query = (
        select(Capture)
        .where(and_(*conditions) if conditions else True)
        .order_by(Capture.timestamp.desc())
        .limit(limit + 1)  # Fetch one extra to check has_more
    )

    result = await db.execute(query)
    captures = list(result.scalars().all())

    # Check if there are more results
    has_more = len(captures) > limit
    if has_more:
        captures = captures[:limit]

    # Get total count (with filters)
    count_query = select(func.count(Capture.id))
    if start_date:
        count_query = count_query.where(
            Capture.timestamp >= datetime.combine(start_date, datetime.min.time())
        )
    if end_date:
        count_query = count_query.where(
            Capture.timestamp <= datetime.combine(end_date, datetime.max.time())
        )
    total_result = await db.execute(count_query)
    total = total_result.scalar() or 0

    # Build response
    timeline_captures = [
        TimelineCapture(
            id=c.id,
            timestamp=c.timestamp,
            filepath=c.filepath,
            width=c.width,
            height=c.height,
            monitor_index=c.monitor_index,
            has_ocr=bool(c.ocr_text),
            text_preview=c.ocr_text[:200] if c.ocr_text else None,
        )
        for c in captures
    ]

    next_cursor = None
    if has_more and captures:
        next_cursor = captures[-1].timestamp.isoformat()

    return TimelineResponse(
        captures=timeline_captures,
        total=total,
        next_cursor=next_cursor,
        has_more=has_more,
    )


@router.get("/days", response_model=list[DaySummary])
async def get_day_summaries(
    start_date: Optional[date] = Query(default=None),
    end_date: Optional[date] = Query(default=None),
    limit: int = Query(default=30, ge=1, le=365),
    db: AsyncSession = Depends(get_db),
) -> list[DaySummary]:
    """Get summary of captures grouped by day.

    Useful for calendar view or date picker.
    Returns days in reverse chronological order.
    """
    # Build date filter
    conditions = []
    if start_date:
        conditions.append(Capture.timestamp >= datetime.combine(start_date, datetime.min.time()))
    if end_date:
        conditions.append(Capture.timestamp <= datetime.combine(end_date, datetime.max.time()))

    # Group by date
    date_expr = func.date(Capture.timestamp)
    query = (
        select(
            date_expr.label("capture_date"),
            func.count(Capture.id).label("count"),
            func.min(Capture.timestamp).label("first_capture"),
            func.max(Capture.timestamp).label("last_capture"),
        )
        .where(and_(*conditions) if conditions else True)
        .group_by(date_expr)
        .order_by(date_expr.desc())
        .limit(limit)
    )

    result = await db.execute(query)
    rows = result.fetchall()

    return [
        DaySummary(
            date=row.capture_date,
            count=row.count,
            first_capture=row.first_capture,
            last_capture=row.last_capture,
        )
        for row in rows
    ]


@router.get("/{capture_id}")
async def get_capture_detail(
    capture_id: str,
    db: AsyncSession = Depends(get_db),
) -> dict:
    """Get detailed information about a specific capture."""
    result = await db.execute(
        select(Capture).where(Capture.id == capture_id)
    )
    capture = result.scalar_one_or_none()

    if not capture:
        from fastapi import HTTPException
        raise HTTPException(status_code=404, detail="Capture not found")

    return {
        "id": capture.id,
        "timestamp": capture.timestamp,
        "filepath": capture.filepath,
        "width": capture.width,
        "height": capture.height,
        "file_size": capture.file_size,
        "monitor_index": capture.monitor_index,
        "ocr_text": capture.ocr_text,
        "processing_status": capture.processing_status,
        "created_at": capture.created_at,
    }
```
  </action>
  <verify>
Run `python -c "from jarvis_server.api.timeline import router; print('Timeline router OK')"` in server/.venv.
  </verify>
  <done>Timeline API created with cursor-based pagination, date filtering, day summaries, and capture detail endpoint.</done>
</task>

<task type="auto">
  <name>Task 2: Register timeline router in app</name>
  <files>
server/src/jarvis_server/api/__init__.py
server/src/jarvis_server/main.py
  </files>
  <action>
Wire timeline router into FastAPI app.

**Update server/src/jarvis_server/api/__init__.py:**
```python
from .captures import router as captures_router
from .health import router as health_router
from .search import router as search_router
from .timeline import router as timeline_router
from ..imports.api import router as import_router

__all__ = [
    "captures_router",
    "health_router",
    "search_router",
    "timeline_router",
    "import_router",
]
```

**Update server/src/jarvis_server/main.py:**
Add timeline router:
```python
from .api import captures_router, health_router, search_router, timeline_router, import_router

# In create_app() or wherever routers are registered:
app.include_router(timeline_router)
```
  </action>
  <verify>
Check main.py includes timeline_router: `grep -q "timeline_router" server/src/jarvis_server/main.py`
  </verify>
  <done>Timeline router registered at /api/timeline in FastAPI app.</done>
</task>

</tasks>

<verification>
1. Router: `python -c "from jarvis_server.api.timeline import router"`
2. Main includes: `grep -q "timeline_router" server/src/jarvis_server/main.py`
3. Import check: `python -c "from jarvis_server.api import timeline_router"`
</verification>

<success_criteria>
- GET /api/timeline/ returns captures with cursor-based pagination
- Supports limit (1-200), cursor, start_date, end_date parameters
- GET /api/timeline/days returns day summaries for calendar view
- GET /api/timeline/{id} returns detailed capture info
- All endpoints use proper async SQLAlchemy queries
- Timeline router registered in FastAPI app
</success_criteria>

<output>
After completion, create `.planning/phases/02-searchable-memory-rag-core/02-08-SUMMARY.md`
</output>
