---
phase: 02-searchable-memory-rag-core
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - server/src/jarvis_server/search/__init__.py
  - server/src/jarvis_server/search/hybrid.py
  - server/src/jarvis_server/search/schemas.py
  - server/src/jarvis_server/api/search.py
  - server/src/jarvis_server/main.py
autonomous: true

must_haves:
  truths:
    - "User can search captured content with natural language queries"
    - "Search combines semantic and keyword matching via hybrid search"
    - "Results can be filtered by time range and source type"
  artifacts:
    - path: "server/src/jarvis_server/search/hybrid.py"
      provides: "Hybrid search implementation"
      exports: ["hybrid_search"]
    - path: "server/src/jarvis_server/api/search.py"
      provides: "Search API endpoint"
      exports: ["router"]
    - path: "server/src/jarvis_server/search/schemas.py"
      provides: "Request/response models"
      exports: ["SearchRequest", "SearchResult"]
  key_links:
    - from: "server/src/jarvis_server/api/search.py"
      to: "server/src/jarvis_server/search/hybrid.py"
      via: "hybrid_search call"
      pattern: "hybrid_search.*query"
    - from: "server/src/jarvis_server/search/hybrid.py"
      to: "qdrant_client"
      via: "query_points with prefetch"
      pattern: "query_points.*prefetch"
---

<objective>
Create hybrid search API combining semantic (dense) and keyword (sparse) matching with temporal filtering.

Purpose: Enable natural language search across all captured content. Hybrid search provides both semantic understanding ("things like X") and exact keyword matching ("contains word Y").

Output: Search module with hybrid Qdrant queries, API endpoint with time/source filters, Pydantic schemas for request/response.
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-searchable-memory-rag-core/02-RESEARCH.md

# Qdrant wrapper from 02-01
@.planning/phases/02-searchable-memory-rag-core/02-01-PLAN.md

# Existing API structure
@server/src/jarvis_server/api/__init__.py
@server/src/jarvis_server/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create search schemas</name>
  <files>
server/src/jarvis_server/search/__init__.py
server/src/jarvis_server/search/schemas.py
  </files>
  <action>
Create search/ module with Pydantic models.

**server/src/jarvis_server/search/__init__.py:**
```python
from .schemas import SearchRequest, SearchResult, SearchResponse
from .hybrid import hybrid_search

__all__ = ["SearchRequest", "SearchResult", "SearchResponse", "hybrid_search"]
```

**server/src/jarvis_server/search/schemas.py:**
```python
"""Search request and response schemas."""
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field


class SearchRequest(BaseModel):
    """Search query parameters."""

    query: str = Field(..., min_length=1, max_length=1000, description="Natural language search query")
    limit: int = Field(default=10, ge=1, le=100, description="Maximum results to return")
    start_date: Optional[datetime] = Field(default=None, description="Filter: earliest timestamp")
    end_date: Optional[datetime] = Field(default=None, description="Filter: latest timestamp")
    sources: Optional[list[str]] = Field(
        default=None,
        description="Filter by source type: screen, chatgpt, claude, grok",
    )

    class Config:
        json_schema_extra = {
            "example": {
                "query": "meeting notes about project alpha",
                "limit": 10,
                "start_date": "2026-01-01T00:00:00Z",
                "sources": ["screen", "chatgpt"],
            }
        }


class SearchResult(BaseModel):
    """Single search result."""

    id: str = Field(..., description="Capture or document ID")
    score: float = Field(..., description="Relevance score (higher is better)")
    text_preview: str = Field(..., description="Preview of matching text")
    timestamp: datetime = Field(..., description="When content was captured/created")
    source: str = Field(..., description="Content source: screen, chatgpt, claude, grok")
    filepath: Optional[str] = Field(default=None, description="Path to image file (for screen captures)")


class SearchResponse(BaseModel):
    """Search response with results and metadata."""

    query: str
    total: int
    results: list[SearchResult]
```
  </action>
  <verify>
Run `python -c "from jarvis_server.search.schemas import SearchRequest, SearchResult, SearchResponse; print('Schemas OK')"` in server/.venv.
  </verify>
  <done>Search schemas defined: SearchRequest with query/limit/filters, SearchResult with id/score/preview/timestamp/source, SearchResponse wrapper.</done>
</task>

<task type="auto">
  <name>Task 2: Implement hybrid search</name>
  <files>server/src/jarvis_server/search/hybrid.py</files>
  <action>
Create hybrid search implementation using Qdrant's prefetch + RRF fusion.

**server/src/jarvis_server/search/hybrid.py:**
```python
"""Hybrid search combining dense and sparse vectors with RRF fusion."""
import logging
from datetime import datetime
from qdrant_client import models

from ..vector.qdrant import get_qdrant
from ..processing.embeddings import get_embedding_processor
from .schemas import SearchRequest, SearchResult

logger = logging.getLogger(__name__)

COLLECTION_NAME = "captures"


def hybrid_search(request: SearchRequest) -> list[SearchResult]:
    """Execute hybrid search with dense + sparse vectors and RRF fusion.

    Uses Qdrant's prefetch to get top-k from each vector type,
    then fuses results using Reciprocal Rank Fusion (RRF).
    """
    qdrant = get_qdrant()
    embedder = get_embedding_processor()

    # Generate query embeddings
    embedding = embedder.embed(request.query)

    # Build filter conditions
    filter_conditions = []

    if request.start_date or request.end_date:
        filter_conditions.append(
            models.FieldCondition(
                key="timestamp",
                range=models.DatetimeRange(
                    gte=request.start_date.isoformat() if request.start_date else None,
                    lte=request.end_date.isoformat() if request.end_date else None,
                ),
            )
        )

    if request.sources:
        filter_conditions.append(
            models.FieldCondition(
                key="source",
                match=models.MatchAny(any=request.sources),
            )
        )

    filter_condition = models.Filter(must=filter_conditions) if filter_conditions else None

    # Prefetch limits - get more candidates for better fusion
    prefetch_limit = min(request.limit * 5, 50)

    # Execute hybrid search with RRF fusion
    results = qdrant.client.query_points(
        collection_name=COLLECTION_NAME,
        prefetch=[
            models.Prefetch(
                query=embedding.dense.tolist(),
                using="dense",
                limit=prefetch_limit,
                filter=filter_condition,
            ),
            models.Prefetch(
                query=models.SparseVector(
                    indices=embedding.sparse_indices,
                    values=embedding.sparse_values,
                ),
                using="sparse",
                limit=prefetch_limit,
                filter=filter_condition,
            ),
        ],
        query=models.FusionQuery(fusion=models.Fusion.RRF),
        limit=request.limit,
        with_payload=True,
    )

    # Convert to SearchResult objects
    search_results = []
    for point in results.points:
        payload = point.payload or {}
        timestamp_str = payload.get("timestamp")

        # Parse timestamp
        if timestamp_str:
            try:
                timestamp = datetime.fromisoformat(timestamp_str.replace("Z", "+00:00"))
            except (ValueError, TypeError):
                timestamp = datetime.now()
        else:
            timestamp = datetime.now()

        search_results.append(
            SearchResult(
                id=str(point.id),
                score=point.score or 0.0,
                text_preview=payload.get("text_preview", ""),
                timestamp=timestamp,
                source=payload.get("source", "screen"),
                filepath=payload.get("filepath"),
            )
        )

    logger.info(f"Hybrid search for '{request.query[:50]}...' returned {len(search_results)} results")
    return search_results
```

Key design choices:
- Prefetch 5x limit from each vector type for better fusion quality
- RRF fusion handles different score distributions from dense/sparse
- Timestamp and source filters applied at Qdrant level (efficient)
- Graceful handling of missing/malformed payload data
  </action>
  <verify>
Run `python -c "from jarvis_server.search.hybrid import hybrid_search; print('Hybrid search OK')"` in server/.venv.
  </verify>
  <done>Hybrid search implemented with dense+sparse prefetch, RRF fusion, timestamp/source filtering at Qdrant level.</done>
</task>

<task type="auto">
  <name>Task 3: Create search API endpoint</name>
  <files>
server/src/jarvis_server/api/search.py
server/src/jarvis_server/api/__init__.py
server/src/jarvis_server/main.py
  </files>
  <action>
Create search API endpoint and wire into FastAPI app.

**server/src/jarvis_server/api/search.py:**
```python
"""Search API endpoints."""
import logging
from fastapi import APIRouter, HTTPException

from ..search.schemas import SearchRequest, SearchResult, SearchResponse
from ..search.hybrid import hybrid_search

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/search", tags=["search"])


@router.post("/", response_model=SearchResponse)
async def search_memories(request: SearchRequest) -> SearchResponse:
    """Search captured memories using natural language.

    Performs hybrid search combining semantic understanding (dense vectors)
    with keyword matching (sparse vectors) using RRF fusion.

    Filters:
    - start_date/end_date: Time range filter
    - sources: Filter by content source (screen, chatgpt, claude, grok)
    """
    try:
        results = hybrid_search(request)
        return SearchResponse(
            query=request.query,
            total=len(results),
            results=results,
        )
    except Exception as e:
        logger.error(f"Search failed: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Search failed")


@router.get("/health")
async def search_health() -> dict:
    """Check if search service is operational."""
    from ..vector.qdrant import get_qdrant

    try:
        qdrant = get_qdrant()
        # Check collection exists
        collections = qdrant.client.get_collections()
        has_captures = any(c.name == "captures" for c in collections.collections)
        return {
            "status": "healthy" if has_captures else "degraded",
            "collection_exists": has_captures,
        }
    except Exception as e:
        return {"status": "unhealthy", "error": str(e)}
```

**Update server/src/jarvis_server/api/__init__.py:**
```python
from .captures import router as captures_router
from .health import router as health_router
from .search import router as search_router

__all__ = ["captures_router", "health_router", "search_router"]
```

**Update server/src/jarvis_server/main.py:**
Add search router to the FastAPI app:
```python
from .api import captures_router, health_router, search_router

# In create_app() or wherever routers are registered:
app.include_router(search_router)
```
  </action>
  <verify>
Run `python -c "from jarvis_server.api.search import router; print('Search router OK')"` in server/.venv.
Check main.py includes search_router.
  </verify>
  <done>Search API endpoint created at POST /api/search/ with hybrid search, time/source filters, and health check endpoint.</done>
</task>

</tasks>

<verification>
1. Schemas: `python -c "from jarvis_server.search import SearchRequest, SearchResult, SearchResponse"`
2. Hybrid search: `python -c "from jarvis_server.search import hybrid_search"`
3. API router: `python -c "from jarvis_server.api.search import router"`
4. Main includes search: `grep -q "search_router" server/src/jarvis_server/main.py`
</verification>

<success_criteria>
- SearchRequest accepts query, limit, start_date, end_date, sources
- SearchResult returns id, score, text_preview, timestamp, source, filepath
- Hybrid search uses prefetch with dense + sparse vectors
- RRF fusion combines results from both vector types
- Filters applied at Qdrant level for efficiency
- POST /api/search/ endpoint registered in FastAPI app
- GET /api/search/health checks Qdrant collection status
</success_criteria>

<output>
After completion, create `.planning/phases/02-searchable-memory-rag-core/02-04-SUMMARY.md`
</output>
