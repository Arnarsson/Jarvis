---
phase: 02-searchable-memory-rag-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/docker-compose.yml
  - server/src/jarvis_server/vector/__init__.py
  - server/src/jarvis_server/vector/qdrant.py
autonomous: true

must_haves:
  truths:
    - "Qdrant collection exists with hybrid vector configuration"
    - "Redis container is running and accessible"
    - "Timestamp payload index enables time-filtered queries"
  artifacts:
    - path: "server/src/jarvis_server/vector/qdrant.py"
      provides: "Qdrant client wrapper with hybrid collection setup"
      exports: ["QdrantWrapper", "setup_captures_collection", "upsert_capture"]
    - path: "server/docker-compose.yml"
      provides: "Redis service configuration"
      contains: "redis:"
  key_links:
    - from: "server/src/jarvis_server/vector/qdrant.py"
      to: "qdrant:6333"
      via: "QdrantClient connection"
      pattern: "QdrantClient.*host"
---

<objective>
Set up infrastructure for RAG pipeline: Redis for task queue and Qdrant collection with hybrid search configuration.

Purpose: Foundation for background processing (Redis/ARQ) and vector storage (Qdrant hybrid search). Both are prerequisites for OCR pipeline and search functionality.

Output: Redis container in docker-compose, Qdrant wrapper with hybrid collection supporting dense (384-dim) and sparse vectors, timestamp payload index for time filtering.
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-searchable-memory-rag-core/02-RESEARCH.md

# Phase 1 foundation
@server/docker-compose.yml
@server/src/jarvis_server/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Redis to Docker Compose</name>
  <files>server/docker-compose.yml</files>
  <action>
Add Redis service to docker-compose.yml for ARQ task queue:

```yaml
redis:
  image: redis:7-alpine
  container_name: jarvis-redis
  ports:
    - "127.0.0.1:6379:6379"
  volumes:
    - redis_data:/data
  networks:
    - jarvis-net
  restart: unless-stopped
  healthcheck:
    test: ["CMD", "redis-cli", "ping"]
    interval: 10s
    timeout: 5s
    retries: 5
```

Also add `redis_data` to the volumes section:
```yaml
redis_data:
  name: jarvis-redis-data
```

Add Redis environment variables to jarvis-server service:
```yaml
- JARVIS_REDIS_HOST=redis
- JARVIS_REDIS_PORT=6379
```
  </action>
  <verify>
Run `docker compose config` in server/ directory - should validate without errors.
Grep for "redis:" in docker-compose.yml to confirm service exists.
  </verify>
  <done>Redis service configured in docker-compose.yml with healthcheck, localhost-only binding, and persistent volume.</done>
</task>

<task type="auto">
  <name>Task 2: Create Qdrant wrapper with hybrid collection and upsert</name>
  <files>
server/src/jarvis_server/vector/__init__.py
server/src/jarvis_server/vector/qdrant.py
server/src/jarvis_server/config.py
  </files>
  <action>
Create vector/ module with Qdrant wrapper.

**server/src/jarvis_server/vector/__init__.py:**
```python
from .qdrant import QdrantWrapper, get_qdrant, setup_captures_collection

__all__ = ["QdrantWrapper", "get_qdrant", "setup_captures_collection"]
```

**server/src/jarvis_server/vector/qdrant.py:**
Create QdrantWrapper class that:
1. Connects to Qdrant using settings from config (JARVIS_QDRANT_HOST, JARVIS_QDRANT_PORT)
2. setup_captures_collection() creates collection with:
   - Dense vectors: "dense" config with size=384 (bge-small-en-v1.5), cosine distance
   - Sparse vectors: "sparse" config with SparseVectorParams
   - Payload indices: "timestamp" (DATETIME), "source" (KEYWORD)
3. Uses models.VectorParams, models.SparseVectorParams, models.SparseIndexParams
4. get_qdrant() function with lru_cache for singleton pattern (matches existing patterns)
5. **upsert_capture() method for storing capture embeddings in Qdrant**

Reference research patterns:
```python
from qdrant_client import QdrantClient, models
from functools import lru_cache
from ..config import get_settings

class QdrantWrapper:
    def __init__(self, host: str, port: int):
        self.client = QdrantClient(host=host, port=port)
        self.collection_name = "captures"

    def setup_captures_collection(self) -> None:
        """Create captures collection with hybrid vector configuration."""
        # Check if collection exists
        collections = self.client.get_collections().collections
        if any(c.name == self.collection_name for c in collections):
            return

        self.client.create_collection(
            collection_name=self.collection_name,
            vectors_config={
                "dense": models.VectorParams(size=384, distance=models.Distance.COSINE)
            },
            sparse_vectors_config={
                "sparse": models.SparseVectorParams(
                    index=models.SparseIndexParams(on_disk=False)
                )
            },
        )
        self.client.create_payload_index(
            collection_name=self.collection_name,
            field_name="timestamp",
            field_schema=models.PayloadSchemaType.DATETIME,
        )
        self.client.create_payload_index(
            collection_name=self.collection_name,
            field_name="source",
            field_schema=models.PayloadSchemaType.KEYWORD,
        )

    def upsert_capture(
        self,
        capture_id: str,
        dense_vector: list[float],
        sparse_indices: list[int],
        sparse_values: list[float],
        payload: dict,
    ) -> None:
        """Upsert a capture's embeddings into Qdrant.

        Args:
            capture_id: Unique ID for the point (capture UUID)
            dense_vector: 384-dim dense embedding from bge-small-en-v1.5
            sparse_indices: Token indices for sparse vector (BM25/SPLADE)
            sparse_values: Token weights for sparse vector
            payload: Metadata dict with timestamp, filepath, text_preview, source
        """
        self.client.upsert(
            collection_name=self.collection_name,
            points=[
                models.PointStruct(
                    id=capture_id,
                    vector={
                        "dense": dense_vector,
                        "sparse": models.SparseVector(
                            indices=sparse_indices,
                            values=sparse_values,
                        ),
                    },
                    payload=payload,
                )
            ],
        )


@lru_cache(maxsize=1)
def get_qdrant() -> QdrantWrapper:
    """Get singleton QdrantWrapper instance."""
    settings = get_settings()
    return QdrantWrapper(host=settings.qdrant_host, port=settings.qdrant_port)


def setup_captures_collection(wrapper: QdrantWrapper | None = None) -> None:
    """Ensure captures collection exists with proper configuration."""
    if wrapper is None:
        wrapper = get_qdrant()
    wrapper.setup_captures_collection()
```

**Update server/src/jarvis_server/config.py:**
Add settings fields:
- redis_host: str = "localhost"
- redis_port: int = 6379

Ensure qdrant_host and qdrant_port already exist from Phase 1 (verify, add if missing).
  </action>
  <verify>
Run `python -c "from jarvis_server.vector import QdrantWrapper, setup_captures_collection"` in server/.venv - should import without errors.
Run `python -c "from jarvis_server.vector.qdrant import QdrantWrapper; print(hasattr(QdrantWrapper, 'upsert_capture'))"` - should print True.
Check that config.py has redis_host and redis_port fields.
  </verify>
  <done>Qdrant wrapper created with hybrid collection setup supporting dense (384-dim) + sparse vectors, timestamp and source payload indices configured, upsert_capture() method for storing embeddings.</done>
</task>

</tasks>

<verification>
1. `docker compose config` validates successfully in server/ directory
2. `grep -q "redis:" server/docker-compose.yml && echo "Redis found"`
3. Python import test: `python -c "from jarvis_server.vector import QdrantWrapper"`
4. Upsert method exists: `python -c "from jarvis_server.vector.qdrant import QdrantWrapper; print(hasattr(QdrantWrapper, 'upsert_capture'))"`
5. Config test: `python -c "from jarvis_server.config import get_settings; s = get_settings(); print(s.redis_host, s.qdrant_host)"`
</verification>

<success_criteria>
- Docker Compose includes Redis service with healthcheck and localhost-only binding
- Qdrant wrapper module exists with hybrid collection configuration
- Collection supports both dense (384-dim) and sparse vectors
- Timestamp and source payload indices defined for filtering
- **upsert_capture() method defined for storing embeddings in Qdrant**
- Config includes redis_host, redis_port, qdrant_host, qdrant_port
</success_criteria>

<output>
After completion, create `.planning/phases/02-searchable-memory-rag-core/02-01-SUMMARY.md`
</output>
