---
phase: 02-searchable-memory-rag-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/docker-compose.yml
  - server/src/jarvis_server/vector/__init__.py
  - server/src/jarvis_server/vector/qdrant.py
autonomous: true

must_haves:
  truths:
    - "Qdrant collection exists with hybrid vector configuration"
    - "Redis container is running and accessible"
    - "Timestamp payload index enables time-filtered queries"
  artifacts:
    - path: "server/src/jarvis_server/vector/qdrant.py"
      provides: "Qdrant client wrapper with hybrid collection setup"
      exports: ["QdrantWrapper", "setup_captures_collection"]
    - path: "server/docker-compose.yml"
      provides: "Redis service configuration"
      contains: "redis:"
  key_links:
    - from: "server/src/jarvis_server/vector/qdrant.py"
      to: "qdrant:6333"
      via: "QdrantClient connection"
      pattern: "QdrantClient.*host"
---

<objective>
Set up infrastructure for RAG pipeline: Redis for task queue and Qdrant collection with hybrid search configuration.

Purpose: Foundation for background processing (Redis/ARQ) and vector storage (Qdrant hybrid search). Both are prerequisites for OCR pipeline and search functionality.

Output: Redis container in docker-compose, Qdrant wrapper with hybrid collection supporting dense (384-dim) and sparse vectors, timestamp payload index for time filtering.
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-searchable-memory-rag-core/02-RESEARCH.md

# Phase 1 foundation
@server/docker-compose.yml
@server/src/jarvis_server/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Redis to Docker Compose</name>
  <files>server/docker-compose.yml</files>
  <action>
Add Redis service to docker-compose.yml for ARQ task queue:

```yaml
redis:
  image: redis:7-alpine
  container_name: jarvis-redis
  ports:
    - "127.0.0.1:6379:6379"
  volumes:
    - redis_data:/data
  networks:
    - jarvis-net
  restart: unless-stopped
  healthcheck:
    test: ["CMD", "redis-cli", "ping"]
    interval: 10s
    timeout: 5s
    retries: 5
```

Also add `redis_data` to the volumes section:
```yaml
redis_data:
  name: jarvis-redis-data
```

Add Redis environment variables to jarvis-server service:
```yaml
- JARVIS_REDIS_HOST=redis
- JARVIS_REDIS_PORT=6379
```
  </action>
  <verify>
Run `docker compose config` in server/ directory - should validate without errors.
Grep for "redis:" in docker-compose.yml to confirm service exists.
  </verify>
  <done>Redis service configured in docker-compose.yml with healthcheck, localhost-only binding, and persistent volume.</done>
</task>

<task type="auto">
  <name>Task 2: Create Qdrant wrapper with hybrid collection</name>
  <files>
server/src/jarvis_server/vector/__init__.py
server/src/jarvis_server/vector/qdrant.py
server/src/jarvis_server/config.py
  </files>
  <action>
Create vector/ module with Qdrant wrapper.

**server/src/jarvis_server/vector/__init__.py:**
```python
from .qdrant import QdrantWrapper, get_qdrant, setup_captures_collection

__all__ = ["QdrantWrapper", "get_qdrant", "setup_captures_collection"]
```

**server/src/jarvis_server/vector/qdrant.py:**
Create QdrantWrapper class that:
1. Connects to Qdrant using settings from config (JARVIS_QDRANT_HOST, JARVIS_QDRANT_PORT)
2. setup_captures_collection() creates collection with:
   - Dense vectors: "dense" config with size=384 (bge-small-en-v1.5), cosine distance
   - Sparse vectors: "sparse" config with SparseVectorParams
   - Payload indices: "timestamp" (DATETIME), "source" (KEYWORD)
3. Uses models.VectorParams, models.SparseVectorParams, models.SparseIndexParams
4. get_qdrant() function with lru_cache for singleton pattern (matches existing patterns)

**Update server/src/jarvis_server/config.py:**
Add settings fields:
- redis_host: str = "localhost"
- redis_port: int = 6379

Ensure qdrant_host and qdrant_port already exist from Phase 1 (verify, add if missing).

Reference research patterns:
```python
client.create_collection(
    collection_name="captures",
    vectors_config={
        "dense": models.VectorParams(size=384, distance=models.Distance.COSINE)
    },
    sparse_vectors_config={
        "sparse": models.SparseVectorParams(
            index=models.SparseIndexParams(on_disk=False)
        )
    },
)
client.create_payload_index(
    collection_name="captures",
    field_name="timestamp",
    field_schema=models.PayloadSchemaType.DATETIME,
)
client.create_payload_index(
    collection_name="captures",
    field_name="source",
    field_schema=models.PayloadSchemaType.KEYWORD,
)
```
  </action>
  <verify>
Run `python -c "from jarvis_server.vector import QdrantWrapper, setup_captures_collection"` in server/.venv - should import without errors.
Check that config.py has redis_host and redis_port fields.
  </verify>
  <done>Qdrant wrapper created with hybrid collection setup supporting dense (384-dim) + sparse vectors, timestamp and source payload indices configured.</done>
</task>

</tasks>

<verification>
1. `docker compose config` validates successfully in server/ directory
2. `grep -q "redis:" server/docker-compose.yml && echo "Redis found"`
3. Python import test: `python -c "from jarvis_server.vector import QdrantWrapper"`
4. Config test: `python -c "from jarvis_server.config import get_settings; s = get_settings(); print(s.redis_host, s.qdrant_host)"`
</verification>

<success_criteria>
- Docker Compose includes Redis service with healthcheck and localhost-only binding
- Qdrant wrapper module exists with hybrid collection configuration
- Collection supports both dense (384-dim) and sparse vectors
- Timestamp and source payload indices defined for filtering
- Config includes redis_host, redis_port, qdrant_host, qdrant_port
</success_criteria>

<output>
After completion, create `.planning/phases/02-searchable-memory-rag-core/02-01-SUMMARY.md`
</output>
