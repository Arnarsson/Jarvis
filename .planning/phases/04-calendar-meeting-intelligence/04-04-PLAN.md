---
phase: 04-calendar-meeting-intelligence
plan: 04
type: execute
wave: 2
depends_on: [04-01, 04-02]
files_modified:
  - server/src/jarvis_server/meetings/__init__.py
  - server/src/jarvis_server/meetings/briefs.py
  - server/src/jarvis_server/api/meetings.py
autonomous: true

must_haves:
  truths:
    - "Pre-meeting briefs are generated with context from memory"
    - "Briefs include relevant search results about meeting topic and attendees"
    - "Briefs can be requested via API for upcoming meetings"
    - "LLM generates coherent brief from context"
  artifacts:
    - path: "server/src/jarvis_server/meetings/briefs.py"
      provides: "Pre-meeting brief generation"
      contains: "generate_pre_meeting_brief"
    - path: "server/src/jarvis_server/api/meetings.py"
      provides: "Brief generation endpoint"
      contains: "brief"
  key_links:
    - from: "server/src/jarvis_server/meetings/briefs.py"
      to: "server/src/jarvis_server/search/service.py"
      via: "Memory search for context"
      pattern: "from.*search.*import"
    - from: "server/src/jarvis_server/meetings/briefs.py"
      to: "anthropic or openai"
      via: "LLM API call"
      pattern: "anthropic|openai"
---

<objective>
Implement pre-meeting brief generation using memory search and LLM

Purpose: Generate contextual briefings before meetings by searching Jarvis memory for relevant information about the meeting topic, attendees, and related discussions. This fulfills CAL-02 requirement.

Output: Pre-meeting brief API endpoint that generates and stores briefs for upcoming meetings
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-calendar-meeting-intelligence/04-RESEARCH.md
@.planning/phases/04-calendar-meeting-intelligence/04-01-SUMMARY.md
@.planning/phases/04-calendar-meeting-intelligence/04-02-SUMMARY.md
@server/src/jarvis_server/search/service.py
@server/src/jarvis_server/calendar/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LLM client dependency and create meetings module</name>
  <files>
    server/pyproject.toml
    server/src/jarvis_server/meetings/__init__.py
  </files>
  <action>
Add Anthropic SDK to server dependencies (or verify it exists) and create meetings module.

Check/update server/pyproject.toml to include:
"anthropic>=0.39.0"

Create server/src/jarvis_server/meetings/__init__.py:
"""Meeting intelligence - briefs, summaries, and action items."""
  </action>
  <verify>
pip install -e server/ && python -c "import anthropic; print('Anthropic SDK available')"
  </verify>
  <done>LLM dependency installed and meetings module created</done>
</task>

<task type="auto">
  <name>Task 2: Create pre-meeting brief generation service</name>
  <files>server/src/jarvis_server/meetings/briefs.py</files>
  <action>
Create the brief generation service that searches memory and generates briefs with LLM.

server/src/jarvis_server/meetings/briefs.py:

import os
import json
from datetime import datetime, timedelta, timezone
from typing import Optional
import anthropic
import structlog
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from jarvis_server.calendar.models import CalendarEvent, Meeting
from jarvis_server.search.service import search_memory

logger = structlog.get_logger()

# LLM client - lazy init
_client: Optional[anthropic.AsyncAnthropic] = None

def get_llm_client() -> anthropic.AsyncAnthropic:
    """Get or create Anthropic client."""
    global _client
    if _client is None:
        api_key = os.getenv("ANTHROPIC_API_KEY")
        if not api_key:
            raise ValueError("ANTHROPIC_API_KEY environment variable not set")
        _client = anthropic.AsyncAnthropic(api_key=api_key)
    return _client

BRIEF_PROMPT = """You are preparing a pre-meeting brief for someone about to join a meeting.

Meeting Details:
- Title: {title}
- Time: {time}
- Attendees: {attendees}
- Description: {description}

Relevant context from their memory/history:
{context}

Generate a concise pre-meeting brief covering:
1. **Key Context**: What's this meeting about based on the title and any related past discussions?
2. **Attendee Notes**: Any relevant recent interactions with the attendees (if found in context).
3. **Open Items**: Any pending questions, action items, or follow-ups related to this topic.
4. **Suggested Preparation**: Quick recommendations for the meeting.

Keep the brief focused and actionable. If there's limited context available, acknowledge that and focus on what can be inferred from the meeting details.

Format with markdown headers and bullet points for easy scanning."""

async def gather_meeting_context(
    event: CalendarEvent,
    db: AsyncSession,
    max_results: int = 10
) -> str:
    """Search memory for context relevant to the meeting."""
    search_terms = []

    # Add meeting title words (skip common words)
    if event.summary:
        words = event.summary.split()
        # Filter out short/common words
        significant = [w for w in words if len(w) > 3 and w.lower() not in
                       {'meeting', 'call', 'sync', 'with', 'about', 'the', 'and', 'for'}]
        search_terms.extend(significant[:3])

    # Add attendee names/emails
    if event.attendees_json:
        attendees = json.loads(event.attendees_json)
        for attendee in attendees[:5]:
            # Extract name or email prefix
            name = attendee.get('displayName') or attendee.get('email', '').split('@')[0]
            if name and len(name) > 2:
                search_terms.append(name)

    if not search_terms:
        return "No specific context found - this appears to be a new topic."

    # Search memory for each term
    all_results = []
    for term in search_terms[:5]:  # Limit queries
        try:
            results = await search_memory(
                db=db,
                query=term,
                limit=5,
                start_date=datetime.now(timezone.utc) - timedelta(days=30)
            )
            all_results.extend(results)
        except Exception as e:
            logger.warning("brief_search_failed", term=term, error=str(e))

    # Deduplicate by ID
    seen_ids = set()
    unique_results = []
    for r in all_results:
        if r.id not in seen_ids:
            seen_ids.add(r.id)
            unique_results.append(r)

    # Format top results
    if not unique_results:
        return "No relevant context found in memory for this meeting."

    context_parts = []
    for i, result in enumerate(unique_results[:max_results], 1):
        source = getattr(result, 'source', 'screen')
        date = getattr(result, 'timestamp', None) or getattr(result, 'created_at', None)
        date_str = date.strftime('%Y-%m-%d') if date else 'Unknown date'
        text = getattr(result, 'ocr_text', None) or getattr(result, 'full_text', None) or str(result)
        # Truncate long text
        if len(text) > 500:
            text = text[:500] + "..."
        context_parts.append(f"{i}. [{source}] {date_str}\n   {text}")

    return "\n\n".join(context_parts)

async def generate_pre_meeting_brief(
    event: CalendarEvent,
    db: AsyncSession
) -> str:
    """
    Generate a pre-meeting brief for a calendar event.

    Args:
        event: The calendar event to generate brief for
        db: Database session for searching memory

    Returns:
        Generated brief text
    """
    logger.info("generating_brief", event_id=event.id, summary=event.summary)

    # Gather context from memory
    context = await gather_meeting_context(event, db)

    # Format attendees
    attendees_list = []
    if event.attendees_json:
        attendees = json.loads(event.attendees_json)
        for a in attendees[:10]:
            name = a.get('displayName') or a.get('email', 'Unknown')
            attendees_list.append(name)
    attendees_str = ", ".join(attendees_list) if attendees_list else "No attendees listed"

    # Build prompt
    prompt = BRIEF_PROMPT.format(
        title=event.summary or "Untitled Meeting",
        time=event.start_time.strftime('%Y-%m-%d %H:%M') if event.start_time else "Unknown",
        attendees=attendees_str,
        description=event.description or "No description provided",
        context=context
    )

    # Call LLM
    try:
        client = get_llm_client()
        message = await client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=1024,
            messages=[
                {"role": "user", "content": prompt}
            ]
        )
        brief = message.content[0].text
        logger.info("brief_generated", event_id=event.id, length=len(brief))
        return brief

    except Exception as e:
        logger.error("brief_generation_failed", event_id=event.id, error=str(e))
        raise

async def get_or_generate_brief(
    event_id: str,
    db: AsyncSession,
    force_regenerate: bool = False
) -> tuple[str, bool]:
    """
    Get cached brief or generate new one.

    Returns:
        Tuple of (brief_text, was_generated)
    """
    # Find event
    result = await db.execute(
        select(CalendarEvent).where(CalendarEvent.id == event_id)
    )
    event = result.scalar_one_or_none()
    if not event:
        raise ValueError(f"Calendar event not found: {event_id}")

    # Check for existing meeting with brief
    if not force_regenerate:
        result = await db.execute(
            select(Meeting).where(Meeting.calendar_event_id == event_id)
        )
        meeting = result.scalar_one_or_none()
        if meeting and meeting.brief:
            return meeting.brief, False

    # Generate new brief
    brief = await generate_pre_meeting_brief(event, db)

    # Store in meeting record (create if needed)
    result = await db.execute(
        select(Meeting).where(Meeting.calendar_event_id == event_id)
    )
    meeting = result.scalar_one_or_none()

    if meeting:
        meeting.brief = brief
        meeting.brief_generated_at = datetime.now(timezone.utc)
    else:
        meeting = Meeting(
            calendar_event_id=event_id,
            detected_at=datetime.now(timezone.utc),
            brief=brief,
            brief_generated_at=datetime.now(timezone.utc)
        )
        db.add(meeting)

    await db.commit()

    return brief, True
  </action>
  <verify>
python -c "
from jarvis_server.meetings.briefs import generate_pre_meeting_brief, gather_meeting_context, get_or_generate_brief
print('Brief generation functions imported successfully')
"
  </verify>
  <done>Pre-meeting brief generation service created</done>
</task>

<task type="auto">
  <name>Task 3: Add brief generation endpoints to meetings API</name>
  <files>server/src/jarvis_server/api/meetings.py</files>
  <action>
Add endpoints for generating and retrieving pre-meeting briefs.

Add to server/src/jarvis_server/api/meetings.py:

class BriefResponse(BaseModel):
    event_id: str
    event_summary: str
    brief: str
    generated_at: Optional[datetime]
    was_cached: bool

@router.post("/brief/{event_id}", response_model=BriefResponse)
async def generate_brief(
    event_id: str,
    force_regenerate: bool = False,
    db: AsyncSession = Depends(get_db_session)
) -> BriefResponse:
    """
    Generate or retrieve pre-meeting brief for a calendar event.

    Args:
        event_id: The calendar event ID
        force_regenerate: If True, regenerate even if cached
    """
    from jarvis_server.meetings.briefs import get_or_generate_brief

    # Get the event for response
    result = await db.execute(
        select(CalendarEvent).where(CalendarEvent.id == event_id)
    )
    event = result.scalar_one_or_none()
    if not event:
        raise HTTPException(status_code=404, detail="Calendar event not found")

    try:
        brief, was_generated = await get_or_generate_brief(event_id, db, force_regenerate)

        return BriefResponse(
            event_id=event_id,
            event_summary=event.summary,
            brief=brief,
            generated_at=datetime.now(timezone.utc) if was_generated else None,
            was_cached=not was_generated
        )
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        logger.error("brief_endpoint_error", event_id=event_id, error=str(e))
        raise HTTPException(status_code=500, detail="Failed to generate brief")

@router.get("/upcoming/briefs", response_model=list[BriefResponse])
async def get_upcoming_briefs(
    hours: int = 24,
    db: AsyncSession = Depends(get_db_session)
) -> list[BriefResponse]:
    """
    Get briefs for all meetings in the next N hours.

    Generates briefs on-demand if not cached.
    """
    from jarvis_server.meetings.briefs import get_or_generate_brief

    now = datetime.now(timezone.utc)
    end = now + timedelta(hours=hours)

    # Get upcoming events
    result = await db.execute(
        select(CalendarEvent)
        .where(CalendarEvent.start_time >= now)
        .where(CalendarEvent.start_time <= end)
        .order_by(CalendarEvent.start_time)
    )
    events = result.scalars().all()

    briefs = []
    for event in events:
        try:
            brief, was_generated = await get_or_generate_brief(event.id, db)
            briefs.append(BriefResponse(
                event_id=event.id,
                event_summary=event.summary,
                brief=brief,
                generated_at=datetime.now(timezone.utc) if was_generated else None,
                was_cached=not was_generated
            ))
        except Exception as e:
            logger.warning("brief_skipped", event_id=event.id, error=str(e))

    return briefs

Add to imports at top:
from datetime import timedelta
  </action>
  <verify>
python -c "
from jarvis_server.api.meetings import router
routes = [r.path for r in router.routes]
print(f'Meeting routes: {routes}')
assert any('brief' in str(r) for r in routes), 'Brief endpoint missing'
print('Brief endpoints verified')
"
  </verify>
  <done>Brief generation endpoints added to meetings API</done>
</task>

</tasks>

<verification>
1. python -c "from jarvis_server.meetings.briefs import generate_pre_meeting_brief" works
2. python -c "import anthropic" works (SDK installed)
3. Meetings API has POST /brief/{event_id} and GET /upcoming/briefs endpoints
4. Brief generation searches memory and calls LLM
5. Briefs are cached in Meeting record
</verification>

<success_criteria>
- Anthropic SDK installed and configured
- Memory search extracts meeting topic and attendee context
- LLM generates coherent briefs from context
- POST /api/meetings/brief/{event_id} generates brief for specific event
- GET /api/meetings/upcoming/briefs generates briefs for next N hours
- Briefs are cached in Meeting.brief field
- force_regenerate option bypasses cache
</success_criteria>

<output>
After completion, create `.planning/phases/04-calendar-meeting-intelligence/04-04-SUMMARY.md`
</output>
