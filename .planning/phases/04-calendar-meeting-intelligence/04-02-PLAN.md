---
phase: 04-calendar-meeting-intelligence
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - server/src/jarvis_server/calendar/sync.py
  - server/src/jarvis_server/processing/tasks.py
  - server/src/jarvis_server/api/calendar.py
autonomous: true

must_haves:
  truths:
    - "Calendar events sync from Google Calendar to local database"
    - "Sync uses incremental tokens to only fetch changed events"
    - "Full sync triggers on first run or token expiration"
    - "Sync can be triggered via API or scheduled task"
  artifacts:
    - path: "server/src/jarvis_server/calendar/sync.py"
      provides: "Incremental calendar sync with sync tokens"
      contains: "incremental_sync"
    - path: "server/src/jarvis_server/api/calendar.py"
      provides: "Sync trigger endpoint"
      contains: "sync"
  key_links:
    - from: "server/src/jarvis_server/calendar/sync.py"
      to: "server/src/jarvis_server/calendar/models.py"
      via: "CalendarEvent import"
      pattern: "from.*models.*import.*CalendarEvent"
    - from: "server/src/jarvis_server/calendar/sync.py"
      to: "server/src/jarvis_server/calendar/oauth.py"
      via: "get_calendar_service import"
      pattern: "from.*oauth.*import.*get_calendar_service"
---

<objective>
Implement Google Calendar incremental sync service

Purpose: Create the sync mechanism that pulls calendar events from Google Calendar into the local database. Uses incremental sync tokens to efficiently fetch only changed events after initial full sync.

Output: Calendar sync service with API trigger and background task support
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-calendar-meeting-intelligence/04-RESEARCH.md
@.planning/phases/04-calendar-meeting-intelligence/04-01-SUMMARY.md
@server/src/jarvis_server/calendar/models.py
@server/src/jarvis_server/calendar/oauth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create calendar sync module with incremental sync</name>
  <files>server/src/jarvis_server/calendar/sync.py</files>
  <action>
Create the sync module that implements Google Calendar incremental sync pattern.

calendar/sync.py:

Imports:
- from datetime import datetime, timezone
- from sqlalchemy.ext.asyncio import AsyncSession
- from sqlalchemy import select
- from googleapiclient.errors import HttpError
- import json
- import structlog
- from jarvis_server.calendar.models import CalendarEvent, SyncState
- from jarvis_server.calendar.oauth import get_calendar_service

logger = structlog.get_logger()

async def get_sync_token(db: AsyncSession, sync_id: str = "calendar_primary") -> str | None:
    """Get stored sync token for incremental sync."""
    result = await db.execute(select(SyncState).where(SyncState.id == sync_id))
    state = result.scalar_one_or_none()
    return state.token if state else None

async def save_sync_token(db: AsyncSession, sync_id: str, token: str) -> None:
    """Save or update sync token."""
    result = await db.execute(select(SyncState).where(SyncState.id == sync_id))
    state = result.scalar_one_or_none()
    if state:
        state.token = token
    else:
        state = SyncState(id=sync_id, token=token)
        db.add(state)
    await db.commit()

async def delete_sync_token(db: AsyncSession, sync_id: str) -> None:
    """Delete sync token to force full resync."""
    result = await db.execute(select(SyncState).where(SyncState.id == sync_id))
    state = result.scalar_one_or_none()
    if state:
        await db.delete(state)
        await db.commit()

async def sync_calendar(db: AsyncSession) -> dict:
    """
    Sync calendar events using incremental sync.

    Returns dict with counts: {"created": N, "updated": N, "deleted": N}
    """
    service = await get_calendar_service()
    sync_token = await get_sync_token(db)

    created, updated, deleted = 0, 0, 0

    try:
        if sync_token:
            # Incremental sync
            logger.info("calendar_sync_incremental", sync_token=sync_token[:20] + "...")
            events_result = service.events().list(
                calendarId='primary',
                syncToken=sync_token
            ).execute()
        else:
            # Full sync - get last 30 days and next 90 days
            logger.info("calendar_sync_full")
            time_min = (datetime.now(timezone.utc) - timedelta(days=30)).isoformat()
            events_result = service.events().list(
                calendarId='primary',
                timeMin=time_min,
                maxResults=2500,
                singleEvents=True,
                orderBy='startTime'
            ).execute()

        # Process all pages
        all_items = events_result.get('items', [])
        while 'nextPageToken' in events_result:
            events_result = service.events().list(
                calendarId='primary',
                pageToken=events_result['nextPageToken']
            ).execute()
            all_items.extend(events_result.get('items', []))

        # Process each event
        for item in all_items:
            google_id = item['id']

            # Check if cancelled (deleted)
            if item.get('status') == 'cancelled':
                result = await db.execute(
                    select(CalendarEvent).where(CalendarEvent.google_event_id == google_id)
                )
                existing = result.scalar_one_or_none()
                if existing:
                    await db.delete(existing)
                    deleted += 1
                continue

            # Parse event data
            event_data = parse_google_event(item)

            # Upsert event
            result = await db.execute(
                select(CalendarEvent).where(CalendarEvent.google_event_id == google_id)
            )
            existing = result.scalar_one_or_none()

            if existing:
                for key, value in event_data.items():
                    setattr(existing, key, value)
                updated += 1
            else:
                event = CalendarEvent(google_event_id=google_id, **event_data)
                db.add(event)
                created += 1

        await db.commit()

        # Save new sync token
        new_token = events_result.get('nextSyncToken')
        if new_token:
            await save_sync_token(db, 'calendar_primary', new_token)

        logger.info("calendar_sync_complete", created=created, updated=updated, deleted=deleted)
        return {"created": created, "updated": updated, "deleted": deleted}

    except HttpError as e:
        if e.resp.status == 410:
            # Sync token expired - full resync needed
            logger.warning("calendar_sync_token_expired")
            await delete_sync_token(db, 'calendar_primary')
            return await sync_calendar(db)  # Retry with full sync
        raise

def parse_google_event(item: dict) -> dict:
    """Parse Google Calendar event into CalendarEvent fields."""
    # Handle all-day events vs timed events
    start = item.get('start', {})
    end = item.get('end', {})

    if 'date' in start:
        # All-day event
        start_time = datetime.fromisoformat(start['date'])
        end_time = datetime.fromisoformat(end['date'])
        all_day = True
    else:
        start_time = datetime.fromisoformat(start['dateTime'])
        end_time = datetime.fromisoformat(end['dateTime'])
        all_day = False

    # Extract meeting link from conferenceData or description
    meeting_link = None
    if 'conferenceData' in item:
        entry_points = item['conferenceData'].get('entryPoints', [])
        for ep in entry_points:
            if ep.get('entryPointType') == 'video':
                meeting_link = ep.get('uri')
                break

    # Serialize attendees
    attendees = item.get('attendees', [])
    attendees_json = json.dumps(attendees) if attendees else None

    return {
        'summary': item.get('summary', '(No title)'),
        'description': item.get('description'),
        'location': item.get('location'),
        'start_time': start_time,
        'end_time': end_time,
        'all_day': all_day,
        'attendees_json': attendees_json,
        'meeting_link': meeting_link,
        'status': item.get('status', 'confirmed'),
        'etag': item.get('etag'),
        'synced_at': datetime.now(timezone.utc),
    }
  </action>
  <verify>
python -c "
from jarvis_server.calendar.sync import sync_calendar, parse_google_event
print('sync_calendar function available')
# Test parse_google_event with mock data
test_event = {
    'id': 'test123',
    'summary': 'Test Meeting',
    'start': {'dateTime': '2026-01-25T10:00:00Z'},
    'end': {'dateTime': '2026-01-25T11:00:00Z'},
}
result = parse_google_event(test_event)
print(f'Parsed event: {result[\"summary\"]} at {result[\"start_time\"]}')
"
  </verify>
  <done>Calendar sync module with incremental sync implemented</done>
</task>

<task type="auto">
  <name>Task 2: Add sync API endpoint and ARQ task</name>
  <files>
    server/src/jarvis_server/api/calendar.py
    server/src/jarvis_server/processing/tasks.py
  </files>
  <action>
Add sync trigger endpoint to calendar API and ARQ background task.

Update api/calendar.py - add new endpoint:

@router.post("/sync")
async def trigger_sync(
    background: bool = False,
    db: AsyncSession = Depends(get_db_session)
) -> dict:
    """
    Trigger calendar sync.

    Args:
        background: If True, queue as ARQ task. If False, sync synchronously.
    """
    from jarvis_server.calendar.oauth import is_authenticated

    if not is_authenticated():
        raise HTTPException(status_code=401, detail="Calendar not authenticated")

    if background:
        # Queue ARQ task
        from jarvis_server.processing.tasks import get_arq_pool
        pool = await get_arq_pool()
        job = await pool.enqueue_job("sync_calendar_task")
        return {"status": "queued", "job_id": job.job_id}
    else:
        from jarvis_server.calendar.sync import sync_calendar
        result = await sync_calendar(db)
        return {"status": "completed", **result}

@router.get("/events")
async def list_events(
    start_date: datetime | None = None,
    end_date: datetime | None = None,
    limit: int = 50,
    db: AsyncSession = Depends(get_db_session)
) -> list[dict]:
    """
    List synced calendar events.

    Args:
        start_date: Filter events starting after this date
        end_date: Filter events ending before this date
        limit: Maximum events to return
    """
    from sqlalchemy import select
    from jarvis_server.calendar.models import CalendarEvent

    query = select(CalendarEvent).order_by(CalendarEvent.start_time)

    if start_date:
        query = query.where(CalendarEvent.start_time >= start_date)
    if end_date:
        query = query.where(CalendarEvent.end_time <= end_date)

    query = query.limit(limit)

    result = await db.execute(query)
    events = result.scalars().all()

    return [
        {
            "id": e.id,
            "summary": e.summary,
            "start_time": e.start_time.isoformat(),
            "end_time": e.end_time.isoformat(),
            "location": e.location,
            "meeting_link": e.meeting_link,
            "attendees": json.loads(e.attendees_json) if e.attendees_json else [],
        }
        for e in events
    ]

Update processing/tasks.py - add calendar sync task:

Add to imports:
from jarvis_server.db.session import async_session_factory

Add new task function:

async def sync_calendar_task(ctx: dict) -> dict:
    """ARQ task to sync calendar in background."""
    from jarvis_server.calendar.sync import sync_calendar

    async with async_session_factory() as db:
        result = await sync_calendar(db)

    return result

Add to WorkerSettings.functions list:
    functions = [
        process_capture,
        process_conversation,
        sync_calendar_task,  # ADD THIS
    ]
  </action>
  <verify>
python -c "
from jarvis_server.api.calendar import router
routes = [r.path for r in router.routes]
print(f'Calendar routes: {routes}')
assert '/sync' in routes or 'sync' in str(routes), 'Sync endpoint missing'
assert '/events' in routes or 'events' in str(routes), 'Events endpoint missing'
print('All calendar endpoints present')
"
  </verify>
  <done>Sync API endpoint and ARQ task added</done>
</task>

</tasks>

<verification>
1. python -c "from jarvis_server.calendar.sync import sync_calendar" works
2. python -c "from jarvis_server.api.calendar import router" shows /sync and /events endpoints
3. ARQ task registered: check processing/tasks.py includes sync_calendar_task
4. Server starts without error: cd server && python -c "from jarvis_server.main import app"
</verification>

<success_criteria>
- Incremental sync uses sync tokens for efficiency
- Full sync on first run or token expiration (410 error)
- Events parsed correctly (timed and all-day)
- Attendees and meeting links extracted
- POST /api/calendar/sync triggers sync (foreground or background)
- GET /api/calendar/events returns synced events with filters
- ARQ task available for scheduled sync
</success_criteria>

<output>
After completion, create `.planning/phases/04-calendar-meeting-intelligence/04-02-SUMMARY.md`
</output>
