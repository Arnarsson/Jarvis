---
phase: 04-calendar-meeting-intelligence
plan: 08
type: execute
wave: 4
depends_on: [04-02, 04-03, 04-04, 04-05, 04-06, 04-07]
files_modified:
  - mcp/src/jarvis_mcp/tools/calendar.py
  - mcp/src/jarvis_mcp/tools/meetings.py
  - mcp/src/jarvis_mcp/server.py
autonomous: true

must_haves:
  truths:
    - "MCP tools expose calendar events to Claude Code"
    - "MCP tools expose meeting summaries and briefs to Claude Code"
    - "User can ask Claude Code about upcoming meetings"
    - "User can get meeting summaries through MCP"
  artifacts:
    - path: "mcp/src/jarvis_mcp/tools/calendar.py"
      provides: "Calendar MCP tools"
      contains: "@mcp.tool()"
    - path: "mcp/src/jarvis_mcp/tools/meetings.py"
      provides: "Meeting MCP tools"
      contains: "@mcp.tool()"
  key_links:
    - from: "mcp/src/jarvis_mcp/tools/calendar.py"
      to: "/api/calendar"
      via: "HTTP client call"
      pattern: "client.get.*api/calendar"
    - from: "mcp/src/jarvis_mcp/tools/meetings.py"
      to: "/api/meetings"
      via: "HTTP client call"
      pattern: "client.get.*api/meetings"
---

<objective>
Implement MCP tools for calendar and meeting intelligence

Purpose: Expose calendar events, pre-meeting briefs, and meeting summaries to Claude Code through MCP tools. This enables the user to interact with calendar and meeting data through natural language.

Output: MCP tools for calendar and meeting access
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-calendar-meeting-intelligence/04-RESEARCH.md
@.planning/phases/03-mcp-server-claude-code/03-03-SUMMARY.md
@mcp/src/jarvis_mcp/tools/search.py
@mcp/src/jarvis_mcp/server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create calendar MCP tools</name>
  <files>mcp/src/jarvis_mcp/tools/calendar.py</files>
  <action>
Create MCP tools for calendar access.

mcp/src/jarvis_mcp/tools/calendar.py:

from datetime import datetime, timedelta
from typing import Annotated, Optional
from pydantic import Field
from mcp.exceptions import ToolError
import structlog
import time

from jarvis_mcp.server import mcp
from jarvis_mcp.client import get_client
from jarvis_mcp.audit import log_mcp_call

logger = structlog.get_logger()

@mcp.tool()
async def get_upcoming_events(
    hours: Annotated[int, Field(
        default=24,
        ge=1,
        le=168,  # Max 1 week
        description="Number of hours to look ahead (default 24)"
    )] = 24,
    limit: Annotated[int, Field(
        default=10,
        ge=1,
        le=50,
        description="Maximum number of events to return"
    )] = 10,
) -> str:
    """Get upcoming calendar events.

    Shows your scheduled meetings and events for the specified time period.
    Useful for checking your schedule and preparing for upcoming meetings.

    Examples:
    - "What meetings do I have today?"
    - "What's on my calendar this week?"
    - "Do I have any meetings in the next 2 hours?"
    """
    start_time = time.monotonic()

    try:
        client = await get_client()

        # Calculate date range
        now = datetime.now()
        end = now + timedelta(hours=hours)

        response = await client.get(
            "/api/calendar/events",
            params={
                "start_date": now.isoformat(),
                "end_date": end.isoformat(),
                "limit": limit
            }
        )
        response.raise_for_status()
        events = response.json()

        if not events:
            result = f"No events scheduled in the next {hours} hours."
        else:
            lines = [f"Found {len(events)} upcoming events:\n"]
            for i, event in enumerate(events, 1):
                start = datetime.fromisoformat(event["start_time"])
                start_str = start.strftime("%a %b %d %I:%M %p")
                summary = event.get("summary", "Untitled")
                location = event.get("location")

                line = f"{i}. **{summary}**\n   {start_str}"
                if location:
                    line += f"\n   Location: {location}"
                if event.get("meeting_link"):
                    line += f"\n   Link: {event['meeting_link']}"

                attendees = event.get("attendees", [])
                if attendees:
                    names = [a.get("displayName") or a.get("email", "?").split("@")[0] for a in attendees[:5]]
                    line += f"\n   With: {', '.join(names)}"
                    if len(attendees) > 5:
                        line += f" (+{len(attendees) - 5} more)"

                lines.append(line)

            result = "\n\n".join(lines)

        await log_mcp_call(
            tool="get_upcoming_events",
            params={"hours": hours, "limit": limit},
            success=True,
            duration_ms=(time.monotonic() - start_time) * 1000
        )
        return result

    except Exception as e:
        logger.exception("get_upcoming_events_failed")
        await log_mcp_call(
            tool="get_upcoming_events",
            params={"hours": hours, "limit": limit},
            success=False,
            duration_ms=(time.monotonic() - start_time) * 1000,
            error=str(e)
        )
        raise ToolError("Failed to fetch calendar events")

@mcp.tool()
async def get_calendar_status() -> str:
    """Check Google Calendar connection status.

    Returns whether Google Calendar is authenticated and syncing.
    If not authenticated, provides guidance on how to set up.
    """
    start_time = time.monotonic()

    try:
        client = await get_client()
        response = await client.get("/api/calendar/auth/status")
        response.raise_for_status()
        status = response.json()

        if status.get("authenticated"):
            result = "Google Calendar is connected and syncing."
        elif status.get("needs_credentials"):
            result = ("Google Calendar is not set up. "
                     "Please place your Google OAuth credentials.json file in the data directory "
                     "and restart the server to begin authentication.")
        else:
            result = ("Google Calendar needs authentication. "
                     "Run the OAuth flow to connect your calendar.")

        await log_mcp_call(
            tool="get_calendar_status",
            params={},
            success=True,
            duration_ms=(time.monotonic() - start_time) * 1000
        )
        return result

    except Exception as e:
        logger.exception("get_calendar_status_failed")
        await log_mcp_call(
            tool="get_calendar_status",
            params={},
            success=False,
            duration_ms=(time.monotonic() - start_time) * 1000,
            error=str(e)
        )
        raise ToolError("Failed to check calendar status")
  </action>
  <verify>
python -c "
from jarvis_mcp.tools.calendar import get_upcoming_events, get_calendar_status
from jarvis_mcp.server import mcp

tools = mcp.list_tools()
tool_names = [t.name for t in tools]
print(f'Tools: {tool_names}')
assert 'get_upcoming_events' in tool_names, 'get_upcoming_events not registered'
assert 'get_calendar_status' in tool_names, 'get_calendar_status not registered'
print('Calendar MCP tools verified')
"
  </verify>
  <done>Calendar MCP tools created and registered</done>
</task>

<task type="auto">
  <name>Task 2: Create meeting MCP tools</name>
  <files>mcp/src/jarvis_mcp/tools/meetings.py</files>
  <action>
Create MCP tools for meeting intelligence.

mcp/src/jarvis_mcp/tools/meetings.py:

from typing import Annotated, Optional
from pydantic import Field
from mcp.exceptions import ToolError
import structlog
import time

from jarvis_mcp.server import mcp
from jarvis_mcp.client import get_client
from jarvis_mcp.audit import log_mcp_call

logger = structlog.get_logger()

@mcp.tool()
async def get_meeting_brief(
    event_id: Annotated[str, Field(
        description="Calendar event ID to get brief for"
    )],
    regenerate: Annotated[bool, Field(
        default=False,
        description="Force regenerate brief even if cached"
    )] = False,
) -> str:
    """Get a pre-meeting brief for a calendar event.

    Generates a contextual briefing by searching your memory for relevant
    information about the meeting topic and attendees.

    Useful before meetings to get caught up on:
    - Previous discussions about this topic
    - Recent interactions with attendees
    - Open action items or follow-ups

    Examples:
    - "Give me a brief for my next meeting"
    - "What context do I have for the product review meeting?"
    """
    start_time = time.monotonic()

    try:
        client = await get_client()

        response = await client.post(
            f"/api/meetings/brief/{event_id}",
            params={"force_regenerate": regenerate}
        )
        response.raise_for_status()
        data = response.json()

        result = f"# Pre-Meeting Brief: {data['event_summary']}\n\n{data['brief']}"

        if data.get("was_cached"):
            result += "\n\n*This brief was cached from a previous request.*"

        await log_mcp_call(
            tool="get_meeting_brief",
            params={"event_id": event_id, "regenerate": regenerate},
            success=True,
            duration_ms=(time.monotonic() - start_time) * 1000
        )
        return result

    except Exception as e:
        logger.exception("get_meeting_brief_failed", event_id=event_id)
        await log_mcp_call(
            tool="get_meeting_brief",
            params={"event_id": event_id, "regenerate": regenerate},
            success=False,
            duration_ms=(time.monotonic() - start_time) * 1000,
            error=str(e)
        )
        if "404" in str(e):
            raise ToolError(f"Calendar event not found: {event_id}")
        raise ToolError("Failed to generate meeting brief")

@mcp.tool()
async def get_meeting_summary(
    meeting_id: Annotated[str, Field(
        description="Meeting ID to get summary for"
    )],
) -> str:
    """Get summary and action items from a past meeting.

    Returns the AI-generated summary, action items with owners,
    key decisions, and follow-ups from a transcribed meeting.

    Examples:
    - "What happened in yesterday's standup?"
    - "What action items came out of the planning meeting?"
    - "Summarize my last meeting"
    """
    start_time = time.monotonic()

    try:
        client = await get_client()

        response = await client.get(f"/api/meetings/summary/{meeting_id}")
        response.raise_for_status()
        data = response.json()

        lines = [f"# Meeting Summary\n"]

        if data.get("calendar_event_summary"):
            lines.append(f"**Meeting:** {data['calendar_event_summary']}\n")

        lines.append(f"## Summary\n{data['summary']}\n")

        action_items = data.get("action_items", [])
        if action_items:
            lines.append("## Action Items")
            for item in action_items:
                owner = item.get("owner") or "Unassigned"
                priority = item.get("priority", "medium")
                due = item.get("due_date")
                line = f"- [{priority.upper()}] {item['task']} (Owner: {owner})"
                if due:
                    line += f" - Due: {due}"
                lines.append(line)
            lines.append("")

        if data.get("transcript_available"):
            lines.append("*Full transcript available*")

        result = "\n".join(lines)

        await log_mcp_call(
            tool="get_meeting_summary",
            params={"meeting_id": meeting_id},
            success=True,
            duration_ms=(time.monotonic() - start_time) * 1000
        )
        return result

    except Exception as e:
        logger.exception("get_meeting_summary_failed", meeting_id=meeting_id)
        await log_mcp_call(
            tool="get_meeting_summary",
            params={"meeting_id": meeting_id},
            success=False,
            duration_ms=(time.monotonic() - start_time) * 1000,
            error=str(e)
        )
        if "404" in str(e):
            raise ToolError(f"Meeting or summary not found: {meeting_id}")
        raise ToolError("Failed to get meeting summary")

@mcp.tool()
async def get_current_meeting() -> str:
    """Check if there's a currently active meeting.

    Returns information about any ongoing meeting detected by the system,
    including the platform (Zoom, Google Meet, etc.) and start time.

    Useful to check:
    - "Am I in a meeting right now?"
    - "What meeting am I in?"
    """
    start_time = time.monotonic()

    try:
        client = await get_client()

        response = await client.get("/api/meetings/current")
        response.raise_for_status()
        data = response.json()

        if not data:
            result = "No active meeting detected."
        else:
            platform = data.get("platform", "Unknown")
            detected_at = data.get("detected_at", "Unknown")
            has_summary = data.get("has_summary", False)

            result = f"Currently in a {platform} meeting.\nStarted: {detected_at}"
            if has_summary:
                result += "\n*Summary available after meeting ends.*"

        await log_mcp_call(
            tool="get_current_meeting",
            params={},
            success=True,
            duration_ms=(time.monotonic() - start_time) * 1000
        )
        return result

    except Exception as e:
        logger.exception("get_current_meeting_failed")
        await log_mcp_call(
            tool="get_current_meeting",
            params={},
            success=False,
            duration_ms=(time.monotonic() - start_time) * 1000,
            error=str(e)
        )
        raise ToolError("Failed to check meeting status")
  </action>
  <verify>
python -c "
from jarvis_mcp.tools.meetings import get_meeting_brief, get_meeting_summary, get_current_meeting
from jarvis_mcp.server import mcp

tools = mcp.list_tools()
tool_names = [t.name for t in tools]
print(f'Tools: {tool_names}')
assert 'get_meeting_brief' in tool_names, 'get_meeting_brief not registered'
assert 'get_meeting_summary' in tool_names, 'get_meeting_summary not registered'
assert 'get_current_meeting' in tool_names, 'get_current_meeting not registered'
print('Meeting MCP tools verified')
"
  </verify>
  <done>Meeting MCP tools created and registered</done>
</task>

<task type="auto">
  <name>Task 3: Register new tools in MCP server</name>
  <files>mcp/src/jarvis_mcp/server.py</files>
  <action>
Update server.py to import the new calendar and meeting tools.

Add to the tool imports section in mcp/src/jarvis_mcp/server.py (after the existing search import):

# Register tools by importing (decorators register with mcp instance)
from jarvis_mcp.tools import search  # noqa: F401 E402
from jarvis_mcp.tools import calendar  # noqa: F401 E402  # ADD THIS
from jarvis_mcp.tools import meetings  # noqa: F401 E402  # ADD THIS
  </action>
  <verify>
python -c "
from jarvis_mcp.server import mcp

tools = mcp.list_tools()
tool_names = [t.name for t in tools]
print(f'All MCP tools: {tool_names}')

expected = ['search_memory', 'get_upcoming_events', 'get_calendar_status',
            'get_meeting_brief', 'get_meeting_summary', 'get_current_meeting']
for tool in expected:
    if 'catch_me_up' not in expected:  # May or may not exist
        assert tool in tool_names, f'{tool} not registered'

print(f'All {len(tool_names)} tools registered successfully')
"
  </verify>
  <done>Calendar and meeting tools registered in MCP server</done>
</task>

</tasks>

<verification>
1. python -c "from jarvis_mcp.tools.calendar import get_upcoming_events" works
2. python -c "from jarvis_mcp.tools.meetings import get_meeting_brief" works
3. mcp.list_tools() includes all calendar and meeting tools
4. Server starts: timeout 2 python -m jarvis_mcp.server 2>&1
</verification>

<success_criteria>
- get_upcoming_events returns calendar events with details
- get_calendar_status shows connection status
- get_meeting_brief generates contextual briefs
- get_meeting_summary returns structured meeting summaries
- get_current_meeting checks for active meetings
- All tools properly audit logged
- All tools handle errors gracefully with ToolError
</success_criteria>

<output>
After completion, create `.planning/phases/04-calendar-meeting-intelligence/04-08-SUMMARY.md`
</output>
