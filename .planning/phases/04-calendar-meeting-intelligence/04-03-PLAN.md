---
phase: 04-calendar-meeting-intelligence
plan: 03
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - agent/src/jarvis/meeting/__init__.py
  - agent/src/jarvis/meeting/detector.py
  - agent/src/jarvis/engine/orchestrator.py
  - server/src/jarvis_server/api/meetings.py
  - server/src/jarvis_server/main.py
autonomous: true

must_haves:
  truths:
    - "Agent detects when user enters a meeting via window title patterns"
    - "Meeting detection reports to server API"
    - "Server creates Meeting record when meeting starts"
    - "Meeting platform is identified (Zoom, Google Meet, Teams)"
  artifacts:
    - path: "agent/src/jarvis/meeting/detector.py"
      provides: "Window-based meeting detection"
      contains: "detect_meeting"
    - path: "server/src/jarvis_server/api/meetings.py"
      provides: "Meeting lifecycle API endpoints"
      contains: "@router.post"
  key_links:
    - from: "agent/src/jarvis/meeting/detector.py"
      to: "agent/src/jarvis/monitor/window.py"
      via: "WindowInfo import"
      pattern: "from.*monitor.*import"
    - from: "agent/src/jarvis/engine/orchestrator.py"
      to: "agent/src/jarvis/meeting/detector.py"
      via: "MeetingDetector integration"
      pattern: "from.*meeting.*import"
---

<objective>
Implement meeting detection via window title pattern matching

Purpose: Detect when the user enters a meeting (Zoom, Google Meet, Microsoft Teams) by monitoring window titles. This enables meeting-related features like audio recording and pre-meeting briefs.

Output: Meeting detection integrated into agent capture loop, server API for meeting lifecycle
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-calendar-meeting-intelligence/04-RESEARCH.md
@.planning/phases/04-calendar-meeting-intelligence/04-01-SUMMARY.md
@agent/src/jarvis/monitor/window.py
@agent/src/jarvis/engine/orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create meeting detector module in agent</name>
  <files>
    agent/src/jarvis/meeting/__init__.py
    agent/src/jarvis/meeting/detector.py
  </files>
  <action>
Create meeting detection module for the desktop agent.

agent/src/jarvis/meeting/__init__.py:
"""Meeting detection and recording for Jarvis agent."""
from jarvis.meeting.detector import MeetingDetector, MeetingState

__all__ = ["MeetingDetector", "MeetingState"]

agent/src/jarvis/meeting/detector.py:

import re
from dataclasses import dataclass
from datetime import datetime, timezone
from enum import Enum
from typing import Optional
import structlog

logger = structlog.get_logger()

class MeetingPlatform(str, Enum):
    ZOOM = "zoom"
    GOOGLE_MEET = "google_meet"
    TEAMS = "teams"
    GENERIC = "generic"

@dataclass
class MeetingState:
    """Current meeting state."""
    in_meeting: bool
    platform: Optional[MeetingPlatform]
    started_at: Optional[datetime]
    window_title: Optional[str]

# Patterns to detect meeting applications
# Format: (regex pattern, platform)
MEETING_PATTERNS = [
    # Zoom - matches "Zoom Meeting", "Zoom Webinar", zoom.us in browser
    (r'zoom\s*(meeting|webinar)?', MeetingPlatform.ZOOM),
    (r'zoom\.us', MeetingPlatform.ZOOM),

    # Google Meet - matches meet.google.com in browser, "Google Meet" app
    (r'meet\.google\.com', MeetingPlatform.GOOGLE_MEET),
    (r'google\s+meet', MeetingPlatform.GOOGLE_MEET),

    # Microsoft Teams - matches "Microsoft Teams", "| Meeting |" in title
    (r'microsoft\s+teams', MeetingPlatform.TEAMS),
    (r'\|\s*meeting\s*\|.*teams', MeetingPlatform.TEAMS),

    # Generic patterns (less reliable, checked last)
    (r'(meeting|call)\s+with', MeetingPlatform.GENERIC),
]

class MeetingDetector:
    """Detects active meetings from window information."""

    def __init__(self):
        self._current_state = MeetingState(
            in_meeting=False,
            platform=None,
            started_at=None,
            window_title=None
        )
        self._patterns = [(re.compile(p, re.IGNORECASE), platform)
                          for p, platform in MEETING_PATTERNS]

    @property
    def current_state(self) -> MeetingState:
        return self._current_state

    def check_window(self, app_name: str, window_title: str) -> MeetingState:
        """
        Check if current window indicates an active meeting.

        Args:
            app_name: Name of the active application
            window_title: Title of the active window

        Returns:
            Updated MeetingState
        """
        combined_text = f"{app_name} {window_title}".lower()

        # Check each pattern
        detected_platform = None
        for pattern, platform in self._patterns:
            if pattern.search(combined_text):
                detected_platform = platform
                break

        was_in_meeting = self._current_state.in_meeting
        now_in_meeting = detected_platform is not None

        # State transitions
        if now_in_meeting and not was_in_meeting:
            # Meeting started
            self._current_state = MeetingState(
                in_meeting=True,
                platform=detected_platform,
                started_at=datetime.now(timezone.utc),
                window_title=window_title
            )
            logger.info(
                "meeting_detected",
                platform=detected_platform.value,
                window_title=window_title
            )

        elif not now_in_meeting and was_in_meeting:
            # Meeting ended
            logger.info(
                "meeting_ended",
                platform=self._current_state.platform.value if self._current_state.platform else None,
                duration_seconds=(datetime.now(timezone.utc) - self._current_state.started_at).total_seconds()
                    if self._current_state.started_at else 0
            )
            self._current_state = MeetingState(
                in_meeting=False,
                platform=None,
                started_at=None,
                window_title=None
            )

        elif now_in_meeting:
            # Still in meeting - update window title if changed
            if window_title != self._current_state.window_title:
                self._current_state = MeetingState(
                    in_meeting=True,
                    platform=self._current_state.platform,
                    started_at=self._current_state.started_at,
                    window_title=window_title
                )

        return self._current_state

    def reset(self):
        """Reset meeting state (e.g., on agent restart)."""
        self._current_state = MeetingState(
            in_meeting=False,
            platform=None,
            started_at=None,
            window_title=None
        )
  </action>
  <verify>
python -c "
from jarvis.meeting.detector import MeetingDetector, MeetingPlatform

detector = MeetingDetector()

# Test Zoom detection
state = detector.check_window('Zoom', 'Zoom Meeting')
assert state.in_meeting, 'Should detect Zoom meeting'
assert state.platform == MeetingPlatform.ZOOM, f'Platform should be Zoom, got {state.platform}'

# Test meeting end
state = detector.check_window('Firefox', 'Google - Mozilla Firefox')
assert not state.in_meeting, 'Should detect meeting ended'

# Test Google Meet
state = detector.check_window('Firefox', 'Meet - abc-defg-hij - Mozilla Firefox')
assert state.in_meeting is False, 'Random window should not trigger'

state = detector.check_window('Chrome', 'meet.google.com/abc-def-ghi')
assert state.in_meeting, 'Should detect Google Meet'
assert state.platform == MeetingPlatform.GOOGLE_MEET

print('All meeting detection tests passed')
"
  </verify>
  <done>Meeting detector module created with pattern-based detection</done>
</task>

<task type="auto">
  <name>Task 2: Create meetings API on server</name>
  <files>
    server/src/jarvis_server/api/meetings.py
    server/src/jarvis_server/main.py
  </files>
  <action>
Create meetings API for meeting lifecycle management.

server/src/jarvis_server/api/meetings.py:

from datetime import datetime, timezone
from typing import Optional
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
import structlog

from jarvis_server.db.session import get_db_session
from jarvis_server.calendar.models import Meeting, CalendarEvent

router = APIRouter(prefix="/api/meetings", tags=["meetings"])
logger = structlog.get_logger()

class MeetingStartRequest(BaseModel):
    platform: str
    window_title: Optional[str] = None
    detected_at: Optional[datetime] = None

class MeetingEndRequest(BaseModel):
    meeting_id: str
    ended_at: Optional[datetime] = None

class MeetingResponse(BaseModel):
    id: str
    platform: Optional[str]
    detected_at: datetime
    ended_at: Optional[datetime]
    calendar_event_id: Optional[str]
    transcript_status: str
    has_summary: bool

@router.post("/start", response_model=MeetingResponse)
async def start_meeting(
    request: MeetingStartRequest,
    db: AsyncSession = Depends(get_db_session)
) -> MeetingResponse:
    """
    Record that a meeting has started.

    Called by the agent when it detects meeting window.
    Attempts to correlate with a calendar event if one exists around this time.
    """
    detected_at = request.detected_at or datetime.now(timezone.utc)

    # Try to find matching calendar event (within 15 min of start time)
    from datetime import timedelta
    window_start = detected_at - timedelta(minutes=15)
    window_end = detected_at + timedelta(minutes=15)

    result = await db.execute(
        select(CalendarEvent)
        .where(CalendarEvent.start_time >= window_start)
        .where(CalendarEvent.start_time <= window_end)
        .order_by(CalendarEvent.start_time)
        .limit(1)
    )
    calendar_event = result.scalar_one_or_none()

    meeting = Meeting(
        platform=request.platform,
        detected_at=detected_at,
        calendar_event_id=calendar_event.id if calendar_event else None,
    )
    db.add(meeting)
    await db.commit()
    await db.refresh(meeting)

    logger.info(
        "meeting_started",
        meeting_id=meeting.id,
        platform=request.platform,
        calendar_event_id=meeting.calendar_event_id
    )

    return MeetingResponse(
        id=meeting.id,
        platform=meeting.platform,
        detected_at=meeting.detected_at,
        ended_at=meeting.ended_at,
        calendar_event_id=meeting.calendar_event_id,
        transcript_status=meeting.transcript_status,
        has_summary=meeting.summary is not None
    )

@router.post("/end", response_model=MeetingResponse)
async def end_meeting(
    request: MeetingEndRequest,
    db: AsyncSession = Depends(get_db_session)
) -> MeetingResponse:
    """Record that a meeting has ended."""
    result = await db.execute(
        select(Meeting).where(Meeting.id == request.meeting_id)
    )
    meeting = result.scalar_one_or_none()

    if not meeting:
        raise HTTPException(status_code=404, detail="Meeting not found")

    meeting.ended_at = request.ended_at or datetime.now(timezone.utc)
    await db.commit()
    await db.refresh(meeting)

    logger.info(
        "meeting_ended",
        meeting_id=meeting.id,
        duration_seconds=(meeting.ended_at - meeting.detected_at).total_seconds()
    )

    return MeetingResponse(
        id=meeting.id,
        platform=meeting.platform,
        detected_at=meeting.detected_at,
        ended_at=meeting.ended_at,
        calendar_event_id=meeting.calendar_event_id,
        transcript_status=meeting.transcript_status,
        has_summary=meeting.summary is not None
    )

@router.get("/current", response_model=Optional[MeetingResponse])
async def get_current_meeting(
    db: AsyncSession = Depends(get_db_session)
) -> Optional[MeetingResponse]:
    """Get the currently active meeting, if any."""
    result = await db.execute(
        select(Meeting)
        .where(Meeting.ended_at.is_(None))
        .order_by(Meeting.detected_at.desc())
        .limit(1)
    )
    meeting = result.scalar_one_or_none()

    if not meeting:
        return None

    return MeetingResponse(
        id=meeting.id,
        platform=meeting.platform,
        detected_at=meeting.detected_at,
        ended_at=meeting.ended_at,
        calendar_event_id=meeting.calendar_event_id,
        transcript_status=meeting.transcript_status,
        has_summary=meeting.summary is not None
    )

@router.get("/{meeting_id}", response_model=MeetingResponse)
async def get_meeting(
    meeting_id: str,
    db: AsyncSession = Depends(get_db_session)
) -> MeetingResponse:
    """Get meeting by ID."""
    result = await db.execute(
        select(Meeting).where(Meeting.id == meeting_id)
    )
    meeting = result.scalar_one_or_none()

    if not meeting:
        raise HTTPException(status_code=404, detail="Meeting not found")

    return MeetingResponse(
        id=meeting.id,
        platform=meeting.platform,
        detected_at=meeting.detected_at,
        ended_at=meeting.ended_at,
        calendar_event_id=meeting.calendar_event_id,
        transcript_status=meeting.transcript_status,
        has_summary=meeting.summary is not None
    )

Update main.py to include meetings router:
from jarvis_server.api.meetings import router as meetings_router
app.include_router(meetings_router)
  </action>
  <verify>
python -c "
from jarvis_server.api.meetings import router
routes = [r.path for r in router.routes]
print(f'Meeting routes: {routes}')
assert '/start' in routes or 'start' in str(routes), 'start endpoint missing'
assert '/end' in routes or 'end' in str(routes), 'end endpoint missing'
assert '/current' in routes or 'current' in str(routes), 'current endpoint missing'
print('All meeting endpoints present')
"
  </verify>
  <done>Meetings API created with start/end/current endpoints</done>
</task>

<task type="auto">
  <name>Task 3: Integrate meeting detector into agent orchestrator</name>
  <files>agent/src/jarvis/engine/orchestrator.py</files>
  <action>
Integrate meeting detection into the capture orchestrator.

Update agent/src/jarvis/engine/orchestrator.py:

Add imports:
from jarvis.meeting.detector import MeetingDetector

Add to CaptureOrchestrator.__init__:
    self._meeting_detector = MeetingDetector()
    self._current_meeting_id: str | None = None

Add method to report meeting to server:

async def _report_meeting_start(self, state: MeetingState) -> None:
    """Report meeting start to server."""
    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self._config.server_url}/api/meetings/start",
                json={
                    "platform": state.platform.value if state.platform else None,
                    "window_title": state.window_title,
                    "detected_at": state.started_at.isoformat() if state.started_at else None,
                },
                timeout=10.0
            )
            response.raise_for_status()
            data = response.json()
            self._current_meeting_id = data["id"]
            self._logger.info("meeting_reported_to_server", meeting_id=self._current_meeting_id)
    except Exception as e:
        self._logger.error("meeting_report_failed", error=str(e))

async def _report_meeting_end(self) -> None:
    """Report meeting end to server."""
    if not self._current_meeting_id:
        return

    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self._config.server_url}/api/meetings/end",
                json={
                    "meeting_id": self._current_meeting_id,
                },
                timeout=10.0
            )
            response.raise_for_status()
            self._logger.info("meeting_end_reported", meeting_id=self._current_meeting_id)
            self._current_meeting_id = None
    except Exception as e:
        self._logger.error("meeting_end_report_failed", error=str(e))

Modify the capture loop (in the method that handles window info):
After getting window info, add:

    # Check for meeting state changes
    prev_in_meeting = self._meeting_detector.current_state.in_meeting
    meeting_state = self._meeting_detector.check_window(
        window_info.app_name,
        window_info.window_title
    )

    if meeting_state.in_meeting and not prev_in_meeting:
        # Meeting just started
        await self._report_meeting_start(meeting_state)
    elif not meeting_state.in_meeting and prev_in_meeting:
        # Meeting just ended
        await self._report_meeting_end()

Also add httpx to imports if not present.
  </action>
  <verify>
python -c "
from jarvis.engine.orchestrator import CaptureOrchestrator
print('CaptureOrchestrator imports successfully')

# Check MeetingDetector is used
import inspect
source = inspect.getsource(CaptureOrchestrator)
assert 'MeetingDetector' in source or 'meeting_detector' in source, 'MeetingDetector not integrated'
print('MeetingDetector integration verified')
"
  </verify>
  <done>Meeting detector integrated into capture orchestrator</done>
</task>

</tasks>

<verification>
1. python -c "from jarvis.meeting.detector import MeetingDetector" works
2. MeetingDetector correctly identifies Zoom, Google Meet, Teams windows
3. python -c "from jarvis_server.api.meetings import router" works
4. POST /api/meetings/start creates Meeting record
5. Agent orchestrator checks window info for meeting patterns
</verification>

<success_criteria>
- Meeting detection via window title patterns (Zoom, Meet, Teams)
- State machine tracks meeting start/end transitions
- Server API: POST /start, POST /end, GET /current, GET /{id}
- Meetings correlated with calendar events (within 15 min window)
- Agent reports meeting lifecycle to server
- Meeting platform identified and stored
</success_criteria>

<output>
After completion, create `.planning/phases/04-calendar-meeting-intelligence/04-03-SUMMARY.md`
</output>
