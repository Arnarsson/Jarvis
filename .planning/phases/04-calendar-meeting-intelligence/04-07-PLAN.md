---
phase: 04-calendar-meeting-intelligence
plan: 07
type: execute
wave: 3
depends_on: [04-04, 04-06]
files_modified:
  - server/src/jarvis_server/meetings/summaries.py
  - server/src/jarvis_server/meetings/tasks.py
  - server/src/jarvis_server/processing/tasks.py
  - server/src/jarvis_server/api/meetings.py
autonomous: true

must_haves:
  truths:
    - "Meeting summaries are generated from transcripts"
    - "Action items are extracted with owner and priority"
    - "Summary generation runs as background task after transcription"
    - "Summaries and action items accessible via API"
  artifacts:
    - path: "server/src/jarvis_server/meetings/summaries.py"
      provides: "Meeting summarization with action item extraction"
      contains: "generate_meeting_summary"
    - path: "server/src/jarvis_server/meetings/tasks.py"
      provides: "ARQ summarization task"
      contains: "summarize_meeting_task"
  key_links:
    - from: "server/src/jarvis_server/meetings/summaries.py"
      to: "anthropic"
      via: "LLM API call"
      pattern: "anthropic"
    - from: "server/src/jarvis_server/meetings/tasks.py"
      to: "server/src/jarvis_server/meetings/summaries.py"
      via: "generate_meeting_summary import"
      pattern: "from.*summaries.*import"
---

<objective>
Implement meeting summarization with action item extraction

Purpose: Generate structured summaries from meeting transcripts, extracting action items with owners and priorities. Uses LLM to analyze transcript and produce actionable output. This fulfills CAL-06 requirement.

Output: Summarization service, ARQ task, and API endpoints for summaries
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-calendar-meeting-intelligence/04-RESEARCH.md
@.planning/phases/04-calendar-meeting-intelligence/04-04-SUMMARY.md
@.planning/phases/04-calendar-meeting-intelligence/04-06-SUMMARY.md
@server/src/jarvis_server/meetings/briefs.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create meeting summarization service</name>
  <files>server/src/jarvis_server/meetings/summaries.py</files>
  <action>
Create the summarization service that uses LLM to analyze transcripts.

server/src/jarvis_server/meetings/summaries.py:

import json
import os
from dataclasses import dataclass
from typing import Optional
import anthropic
import structlog

logger = structlog.get_logger()

@dataclass
class ActionItem:
    """An action item extracted from meeting."""
    task: str
    owner: Optional[str]
    due_date: Optional[str]
    priority: str  # high, medium, low

@dataclass
class MeetingSummary:
    """Structured meeting summary."""
    summary: str
    action_items: list[ActionItem]
    key_decisions: list[str]
    follow_ups: list[str]

# LLM client singleton
_client: Optional[anthropic.AsyncAnthropic] = None

def get_llm_client() -> anthropic.AsyncAnthropic:
    """Get or create Anthropic client."""
    global _client
    if _client is None:
        api_key = os.getenv("ANTHROPIC_API_KEY")
        if not api_key:
            raise ValueError("ANTHROPIC_API_KEY environment variable not set")
        _client = anthropic.AsyncAnthropic(api_key=api_key)
    return _client

SUMMARY_PROMPT = """Analyze this meeting transcript and extract a structured summary.

<transcript>
{transcript}
</transcript>

For each action item you identify, determine:
- Task description (what needs to be done)
- Assigned owner (who is responsible, if mentioned - use name or "Unassigned")
- Due date (if specified, otherwise null)
- Priority (high/medium/low based on urgency cues in discussion)

Return your analysis as JSON in this exact format:
{{
  "summary": "2-3 sentence meeting summary focusing on key outcomes",
  "action_items": [
    {{
      "task": "string",
      "owner": "string or null",
      "due_date": "string or null",
      "priority": "high|medium|low"
    }}
  ],
  "key_decisions": ["string"],
  "follow_ups": ["string"]
}}

Focus on:
- Concrete, actionable items (not general discussion points)
- Decisions that were actually made (not just discussed)
- Topics requiring follow-up in future meetings

Return ONLY valid JSON, no additional text."""

async def generate_meeting_summary(
    transcript: str,
    meeting_title: Optional[str] = None
) -> MeetingSummary:
    """
    Generate a structured summary from meeting transcript.

    Args:
        transcript: Full meeting transcript text
        meeting_title: Optional title for context

    Returns:
        MeetingSummary with action items and key decisions
    """
    logger.info("summary_generation_started", transcript_length=len(transcript))

    # Truncate very long transcripts (keep first and last portions)
    max_chars = 100000  # ~25k tokens
    if len(transcript) > max_chars:
        half = max_chars // 2
        transcript = transcript[:half] + "\n\n[... middle portion omitted for length ...]\n\n" + transcript[-half:]
        logger.info("transcript_truncated", original_length=len(transcript), truncated_to=max_chars)

    prompt = SUMMARY_PROMPT.format(transcript=transcript)

    if meeting_title:
        prompt = f"Meeting: {meeting_title}\n\n{prompt}"

    try:
        client = get_llm_client()
        message = await client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=2048,
            messages=[
                {"role": "user", "content": prompt}
            ]
        )

        response_text = message.content[0].text

        # Parse JSON response
        # Handle potential markdown code blocks
        if response_text.startswith("```"):
            lines = response_text.split("\n")
            # Remove first and last lines (```json and ```)
            response_text = "\n".join(lines[1:-1])

        data = json.loads(response_text)

        action_items = [
            ActionItem(
                task=item["task"],
                owner=item.get("owner"),
                due_date=item.get("due_date"),
                priority=item.get("priority", "medium")
            )
            for item in data.get("action_items", [])
        ]

        result = MeetingSummary(
            summary=data.get("summary", ""),
            action_items=action_items,
            key_decisions=data.get("key_decisions", []),
            follow_ups=data.get("follow_ups", [])
        )

        logger.info(
            "summary_generation_completed",
            summary_length=len(result.summary),
            action_item_count=len(action_items),
            decision_count=len(result.key_decisions)
        )

        return result

    except json.JSONDecodeError as e:
        logger.error("summary_json_parse_failed", error=str(e), response=response_text[:500])
        raise ValueError(f"Failed to parse LLM response as JSON: {e}")
    except Exception as e:
        logger.error("summary_generation_failed", error=str(e))
        raise

def summary_to_dict(summary: MeetingSummary) -> dict:
    """Convert MeetingSummary to JSON-serializable dict."""
    return {
        "summary": summary.summary,
        "action_items": [
            {
                "task": item.task,
                "owner": item.owner,
                "due_date": item.due_date,
                "priority": item.priority
            }
            for item in summary.action_items
        ],
        "key_decisions": summary.key_decisions,
        "follow_ups": summary.follow_ups
    }
  </action>
  <verify>
python -c "
from jarvis_server.meetings.summaries import generate_meeting_summary, MeetingSummary, ActionItem, summary_to_dict

print('Summary service imported successfully')

# Test ActionItem dataclass
item = ActionItem(task='Test task', owner='John', due_date='2026-01-30', priority='high')
print(f'ActionItem: {item}')

# Test summary_to_dict
summary = MeetingSummary(
    summary='Test summary',
    action_items=[item],
    key_decisions=['Decision 1'],
    follow_ups=['Follow up 1']
)
d = summary_to_dict(summary)
print(f'Summary dict keys: {d.keys()}')
print('Summary service verified')
"
  </verify>
  <done>Meeting summarization service created</done>
</task>

<task type="auto">
  <name>Task 2: Create summarization ARQ task</name>
  <files>
    server/src/jarvis_server/meetings/tasks.py
    server/src/jarvis_server/processing/tasks.py
  </files>
  <action>
Create the ARQ task for summarizing meetings after transcription.

server/src/jarvis_server/meetings/tasks.py:

import json
from datetime import datetime, timezone
from sqlalchemy import select
import structlog

from jarvis_server.db.session import async_session_factory
from jarvis_server.calendar.models import Meeting, CalendarEvent
from jarvis_server.meetings.summaries import generate_meeting_summary, summary_to_dict

logger = structlog.get_logger()

async def summarize_meeting_task(ctx: dict, meeting_id: str) -> dict:
    """
    ARQ task to summarize a transcribed meeting.

    Args:
        ctx: ARQ context
        meeting_id: ID of meeting to summarize

    Returns:
        Dict with summarization status
    """
    logger.info("summarization_task_started", meeting_id=meeting_id)

    async with async_session_factory() as db:
        # Get meeting record
        result = await db.execute(
            select(Meeting).where(Meeting.id == meeting_id)
        )
        meeting = result.scalar_one_or_none()

        if not meeting:
            logger.error("summarization_meeting_not_found", meeting_id=meeting_id)
            return {"status": "error", "reason": "meeting_not_found"}

        if not meeting.transcript:
            logger.error("summarization_no_transcript", meeting_id=meeting_id)
            return {"status": "error", "reason": "no_transcript"}

        # Get meeting title from calendar event if linked
        meeting_title = None
        if meeting.calendar_event_id:
            result = await db.execute(
                select(CalendarEvent).where(CalendarEvent.id == meeting.calendar_event_id)
            )
            event = result.scalar_one_or_none()
            if event:
                meeting_title = event.summary

        try:
            # Generate summary
            summary = await generate_meeting_summary(
                transcript=meeting.transcript,
                meeting_title=meeting_title
            )

            # Store in meeting record
            meeting.summary = summary.summary
            meeting.action_items_json = json.dumps([
                {
                    "task": item.task,
                    "owner": item.owner,
                    "due_date": item.due_date,
                    "priority": item.priority
                }
                for item in summary.action_items
            ])

            await db.commit()

            logger.info(
                "summarization_task_completed",
                meeting_id=meeting_id,
                action_items=len(summary.action_items),
                decisions=len(summary.key_decisions)
            )

            return {
                "status": "completed",
                "meeting_id": meeting_id,
                "summary_length": len(summary.summary),
                "action_item_count": len(summary.action_items),
                "key_decisions": summary.key_decisions,
                "follow_ups": summary.follow_ups
            }

        except Exception as e:
            logger.exception("summarization_task_failed", meeting_id=meeting_id)
            return {"status": "error", "reason": str(e)}

Update server/src/jarvis_server/processing/tasks.py:

Add to imports:
from jarvis_server.meetings.tasks import summarize_meeting_task

Add to WorkerSettings.functions list:
    functions = [
        process_capture,
        process_conversation,
        sync_calendar_task,
        transcribe_meeting_task,
        summarize_meeting_task,  # ADD THIS
    ]

Also update transcription/tasks.py to auto-queue summarization after transcription completes:
After the successful transcription block (where transcript_status is set to "completed"):

            # Queue summarization task
            try:
                from arq import ArqRedis
                redis = ctx.get('redis')
                if redis:
                    await redis.enqueue_job("summarize_meeting_task", meeting_id)
                    logger.info("summarization_queued", meeting_id=meeting_id)
            except Exception as e:
                logger.warning("summarization_queue_failed", meeting_id=meeting_id, error=str(e))
  </action>
  <verify>
python -c "
from jarvis_server.meetings.tasks import summarize_meeting_task
from jarvis_server.processing.tasks import WorkerSettings

print('summarize_meeting_task imported successfully')

# Verify it's in worker functions
func_names = [f.__name__ for f in WorkerSettings.functions]
print(f'Worker functions: {func_names}')
assert 'summarize_meeting_task' in func_names, 'Task not registered in worker'
print('Summarization task verified in worker')
"
  </verify>
  <done>Summarization ARQ task created and registered</done>
</task>

<task type="auto">
  <name>Task 3: Add summary endpoints to meetings API</name>
  <files>server/src/jarvis_server/api/meetings.py</files>
  <action>
Add endpoints for retrieving meeting summaries and action items.

Add to server/src/jarvis_server/api/meetings.py:

class ActionItemResponse(BaseModel):
    task: str
    owner: Optional[str]
    due_date: Optional[str]
    priority: str

class SummaryResponse(BaseModel):
    meeting_id: str
    summary: str
    action_items: list[ActionItemResponse]
    transcript_available: bool
    calendar_event_summary: Optional[str]

@router.get("/summary/{meeting_id}", response_model=SummaryResponse)
async def get_meeting_summary(
    meeting_id: str,
    db: AsyncSession = Depends(get_db_session)
) -> SummaryResponse:
    """Get summary and action items for a meeting."""
    result = await db.execute(
        select(Meeting).where(Meeting.id == meeting_id)
    )
    meeting = result.scalar_one_or_none()

    if not meeting:
        raise HTTPException(status_code=404, detail="Meeting not found")

    if not meeting.summary:
        raise HTTPException(status_code=404, detail="No summary available for this meeting")

    # Get calendar event title if linked
    event_summary = None
    if meeting.calendar_event_id:
        result = await db.execute(
            select(CalendarEvent).where(CalendarEvent.id == meeting.calendar_event_id)
        )
        event = result.scalar_one_or_none()
        if event:
            event_summary = event.summary

    # Parse action items
    action_items = []
    if meeting.action_items_json:
        items = json.loads(meeting.action_items_json)
        action_items = [ActionItemResponse(**item) for item in items]

    return SummaryResponse(
        meeting_id=meeting.id,
        summary=meeting.summary,
        action_items=action_items,
        transcript_available=meeting.transcript is not None,
        calendar_event_summary=event_summary
    )

@router.get("/transcript/{meeting_id}")
async def get_meeting_transcript(
    meeting_id: str,
    db: AsyncSession = Depends(get_db_session)
) -> dict:
    """Get full transcript for a meeting."""
    result = await db.execute(
        select(Meeting).where(Meeting.id == meeting_id)
    )
    meeting = result.scalar_one_or_none()

    if not meeting:
        raise HTTPException(status_code=404, detail="Meeting not found")

    if not meeting.transcript:
        raise HTTPException(status_code=404, detail="No transcript available for this meeting")

    return {
        "meeting_id": meeting.id,
        "transcript": meeting.transcript,
        "transcript_status": meeting.transcript_status
    }

@router.post("/summarize/{meeting_id}")
async def trigger_summarization(
    meeting_id: str,
    db: AsyncSession = Depends(get_db_session)
) -> dict:
    """
    Manually trigger summarization for a meeting.

    Useful for re-summarizing or if auto-queue failed.
    """
    result = await db.execute(
        select(Meeting).where(Meeting.id == meeting_id)
    )
    meeting = result.scalar_one_or_none()

    if not meeting:
        raise HTTPException(status_code=404, detail="Meeting not found")

    if not meeting.transcript:
        raise HTTPException(status_code=400, detail="Meeting has no transcript")

    # Queue summarization task
    from jarvis_server.processing.tasks import get_arq_pool
    try:
        pool = await get_arq_pool()
        job = await pool.enqueue_job("summarize_meeting_task", meeting_id)
        return {"status": "queued", "job_id": job.job_id, "meeting_id": meeting_id}
    except Exception as e:
        logger.error("summarization_queue_failed", meeting_id=meeting_id, error=str(e))
        raise HTTPException(status_code=500, detail="Failed to queue summarization")
  </action>
  <verify>
python -c "
from jarvis_server.api.meetings import router
routes = [r.path for r in router.routes]
print(f'Meeting routes: {routes}')
assert any('summary' in str(r) for r in routes), 'Summary endpoint missing'
assert any('transcript' in str(r) for r in routes), 'Transcript endpoint missing'
print('Summary endpoints verified')
"
  </verify>
  <done>Summary and transcript endpoints added to API</done>
</task>

</tasks>

<verification>
1. python -c "from jarvis_server.meetings.summaries import generate_meeting_summary" works
2. python -c "from jarvis_server.meetings.tasks import summarize_meeting_task" works
3. ARQ task registered in WorkerSettings
4. Meetings API has GET /summary/{meeting_id} endpoint
5. Meetings API has GET /transcript/{meeting_id} endpoint
6. Meetings API has POST /summarize/{meeting_id} endpoint
</verification>

<success_criteria>
- Summarization uses LLM (Claude) to analyze transcripts
- Action items extracted with task, owner, due_date, priority
- Key decisions and follow-ups identified
- ARQ task auto-queued after transcription completes
- Summary and action items stored in Meeting record
- API endpoints return structured summary data
- Long transcripts truncated to stay within token limits
</success_criteria>

<output>
After completion, create `.planning/phases/04-calendar-meeting-intelligence/04-07-SUMMARY.md`
</output>
