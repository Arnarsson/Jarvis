---
phase: 01-privacy-first-capture-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - agent/src/jarvis/capture/__init__.py
  - agent/src/jarvis/capture/screenshot.py
  - agent/src/jarvis/capture/change.py
autonomous: true

must_haves:
  truths:
    - "Screenshots can be captured from any monitor"
    - "Change detection skips redundant captures when screen unchanged"
    - "Hybrid trigger captures at minimum interval even without changes"
  artifacts:
    - path: "agent/src/jarvis/capture/screenshot.py"
      provides: "Multi-monitor screenshot capture"
      contains: "class ScreenCapture"
    - path: "agent/src/jarvis/capture/change.py"
      provides: "Change detection with imagehash"
      contains: "class ChangeDetector"
  key_links:
    - from: "agent/src/jarvis/capture/screenshot.py"
      to: "mss"
      via: "Screenshot grabbing"
      pattern: "mss\\.mss\\(\\)"
    - from: "agent/src/jarvis/capture/change.py"
      to: "imagehash"
      via: "Perceptual hashing"
      pattern: "imagehash\\.(dhash|phash)"
---

<objective>
Implement core screenshot capture with multi-monitor support and change detection.

Purpose: Provides the foundational capture capabilities (CAPT-01, CAPT-02) that efficiently capture screen content only when meaningful changes occur.
Output: Screenshot capture module with mss and change detection using perceptual hashing.
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-privacy-first-capture-foundation/01-RESEARCH.md
@.planning/phases/01-privacy-first-capture-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Multi-monitor screenshot capture</name>
  <files>
    agent/src/jarvis/capture/__init__.py
    agent/src/jarvis/capture/screenshot.py
  </files>
  <action>
Implement screenshot capture using mss library:

1. Create `agent/src/jarvis/capture/screenshot.py`:
   - Class `ScreenCapture`:
     - `__init__(self, jpeg_quality: int = 80)` - stores quality setting
     - `get_monitors(self) -> list[dict]` - returns list of monitor geometries (skip monitor[0] which is "all combined")
     - `capture_monitor(self, monitor_index: int) -> tuple[Image.Image, bytes]` - captures specific monitor, returns PIL Image and JPEG bytes
     - `capture_active(self) -> list[tuple[int, Image.Image, bytes]]` - captures active monitor + any others with activity (for now, just capture primary)
     - Use context manager pattern: `with mss.mss() as sct`

   - Helper function `compress_to_jpeg(img: Image.Image, quality: int = 80) -> bytes`:
     - Use BytesIO buffer
     - Save with optimize=True, progressive=True
     - Return bytes

2. Create `agent/src/jarvis/capture/__init__.py` exporting ScreenCapture

Reference the mss code pattern from research:
- `sct.grab(monitor)` returns ScreenShot object
- Convert with `Image.frombytes("RGB", screenshot.size, screenshot.bgra, "raw", "BGRX")`

Do NOT capture all monitors by default - only primary. Multi-monitor will be enhanced in capture orchestrator.
  </action>
  <verify>
cd /home/sven/Documents/jarvis/agent && python -c "
from jarvis.capture import ScreenCapture
sc = ScreenCapture()
monitors = sc.get_monitors()
print(f'Found {len(monitors)} monitor(s)')
idx, img, data = sc.capture_active()[0]
print(f'Captured monitor {idx}: {img.size}, {len(data)} bytes JPEG')
"
  </verify>
  <done>Can capture screenshots from monitors, JPEG compression works</done>
</task>

<task type="auto">
  <name>Task 2: Change detection with hybrid trigger</name>
  <files>
    agent/src/jarvis/capture/change.py
  </files>
  <action>
Implement change detection using imagehash:

1. Create `agent/src/jarvis/capture/change.py`:
   - Class `ChangeDetector`:
     - `__init__(self, hash_threshold: int = 5, min_interval: float = 15.0)`:
       - `self.hash_threshold` - hamming distance below this means similar
       - `self.min_interval` - minimum seconds between captures (fallback)
       - `self.last_hashes: dict[int, imagehash.ImageHash]` - per-monitor last hash
       - `self.last_capture_times: dict[int, float]` - per-monitor last capture time

     - `should_capture(self, monitor_index: int, img: Image.Image) -> tuple[bool, str]`:
       - Returns (should_capture, reason)
       - Reasons: "first_capture", "interval_elapsed", "content_changed", "no_change"
       - Logic:
         1. If no previous hash for monitor -> return (True, "first_capture")
         2. If elapsed time >= min_interval -> return (True, "interval_elapsed")
         3. Compute dhash of current image
         4. If hamming distance > threshold -> return (True, "content_changed")
         5. Else -> return (False, "no_change")

     - `record_capture(self, monitor_index: int, img: Image.Image)`:
       - Updates last_hashes[monitor_index] with current dhash
       - Updates last_capture_times[monitor_index] with current time

     - `reset(self)`:
       - Clears all hashes and times

Use imagehash.dhash() for speed (faster than phash, good enough for screenshots).
Use time.monotonic() for timing (not affected by clock changes).
  </action>
  <verify>
cd /home/sven/Documents/jarvis/agent && python -c "
from jarvis.capture import ScreenCapture
from jarvis.capture.change import ChangeDetector
from PIL import Image
import time

sc = ScreenCapture()
cd = ChangeDetector(min_interval=1.0)

# First capture should always trigger
_, img, _ = sc.capture_active()[0]
should, reason = cd.should_capture(0, img)
print(f'First: should={should}, reason={reason}')
cd.record_capture(0, img)

# Immediate second capture of same screen should not trigger
should, reason = cd.should_capture(0, img)
print(f'Same screen: should={should}, reason={reason}')

# Wait for interval and same screen should trigger
time.sleep(1.1)
should, reason = cd.should_capture(0, img)
print(f'After interval: should={should}, reason={reason}')
"
  </verify>
  <done>Change detection correctly identifies first capture, unchanged screens, and interval-based triggers</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. ScreenCapture can enumerate monitors and capture screenshots
2. JPEG compression produces reasonable file sizes (~50-200KB per screenshot)
3. ChangeDetector correctly identifies when to capture based on content changes and time interval
4. Hybrid trigger logic works: captures on change OR when interval elapsed
</verification>

<success_criteria>
- Screenshot capture works on primary monitor (covers CAPT-01)
- Change detection skips redundant captures (covers CAPT-02)
- Hybrid trigger ensures minimum capture frequency
- JPEG compression with quality=80 produces reasonable sizes
</success_criteria>

<output>
After completion, create `.planning/phases/01-privacy-first-capture-foundation/01-03-SUMMARY.md`
</output>
