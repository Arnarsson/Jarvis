---
phase: 01-privacy-first-capture-foundation
plan: 05
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - agent/src/jarvis/monitor/__init__.py
  - agent/src/jarvis/monitor/idle.py
  - agent/src/jarvis/monitor/window.py
autonomous: true

must_haves:
  truths:
    - "Idle detection correctly identifies when user has no input for threshold period"
    - "Window detection returns current active application name and title"
    - "Exclusion filter correctly blocks capture for password managers"
  artifacts:
    - path: "agent/src/jarvis/monitor/idle.py"
      provides: "Input activity monitoring"
      contains: "class IdleDetector"
    - path: "agent/src/jarvis/monitor/window.py"
      provides: "Active window detection and exclusion filtering"
      contains: "class WindowMonitor"
  key_links:
    - from: "agent/src/jarvis/monitor/idle.py"
      to: "pynput"
      via: "Input listeners"
      pattern: "from pynput import"
    - from: "agent/src/jarvis/monitor/window.py"
      to: "pywinctl"
      via: "Active window detection"
      pattern: "pywinctl"
---

<objective>
Implement idle detection and window monitoring with exclusion filtering.

Purpose: Enables pausing capture during user inactivity (CAPT-05 efficiency) and blocking capture for sensitive applications (CAPT-03 privacy).
Output: Idle detector using pynput and window monitor with exclusion filter using PyWinCtl.
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-privacy-first-capture-foundation/01-RESEARCH.md
@.planning/phases/01-privacy-first-capture-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Idle detection with pynput</name>
  <files>
    agent/src/jarvis/monitor/__init__.py
    agent/src/jarvis/monitor/idle.py
  </files>
  <action>
Implement idle detection using pynput:

1. Create `agent/src/jarvis/monitor/idle.py`:
   - Class `IdleDetector`:
     - `__init__(self, idle_threshold: float = 300.0)`:
       - `self.idle_threshold` - seconds of inactivity before considered idle (default 5 min)
       - `self.last_activity` - timestamp of last input event
       - `self._lock` - threading.Lock for thread-safe access
       - `self._running` - boolean flag
       - `self._mouse_listener` - pynput mouse listener
       - `self._keyboard_listener` - pynput keyboard listener

     - `_on_activity(self, *args)`:
       - Updates last_activity timestamp (thread-safe with lock)

     - `is_idle(self) -> bool`:
       - Returns True if time since last_activity > idle_threshold
       - Thread-safe read with lock

     - `get_idle_time(self) -> float`:
       - Returns seconds since last activity

     - `start(self)`:
       - Creates and starts mouse listener (on_move, on_click, on_scroll)
       - Creates and starts keyboard listener (on_press)
       - Sets _running = True
       - Initializes last_activity to current time

     - `stop(self)`:
       - Stops both listeners
       - Sets _running = False

     - `__enter__` and `__exit__` for context manager support

Use time.monotonic() for timestamps. Use threading.Lock for thread safety.
Do NOT use daemon threads - use proper start/stop lifecycle.

2. Create `agent/src/jarvis/monitor/__init__.py` exporting IdleDetector

Reference the pynput pattern from research but ensure proper cleanup on stop().
  </action>
  <verify>
cd /home/sven/Documents/jarvis/agent && python -c "
from jarvis.monitor.idle import IdleDetector
import time

# Test basic functionality (without actual input - just API)
detector = IdleDetector(idle_threshold=1.0)
detector.start()
print(f'Started, idle={detector.is_idle()}, idle_time={detector.get_idle_time():.1f}s')
time.sleep(0.5)
print(f'After 0.5s, idle={detector.is_idle()}, idle_time={detector.get_idle_time():.1f}s')
detector.stop()
print('Stopped successfully')
"
  </verify>
  <done>IdleDetector starts/stops cleanly, reports idle status based on threshold</done>
</task>

<task type="auto">
  <name>Task 2: Window detection and exclusion filter</name>
  <files>
    agent/src/jarvis/monitor/window.py
  </files>
  <action>
Implement window monitoring and exclusion filtering using PyWinCtl:

1. Create `agent/src/jarvis/monitor/window.py`:
   - Class `WindowInfo`:
     - Dataclass or NamedTuple with: app_name, window_title, is_active

   - Class `WindowMonitor`:
     - `__init__(self)`:
       - No persistent state needed

     - `get_active_window(self) -> WindowInfo | None`:
       - Uses pywinctl.getActiveWindow()
       - Returns WindowInfo with app_name, window_title, is_active=True
       - Returns None if no active window (screen locked, etc.)
       - Handle exceptions gracefully (return None)

   - Class `ExclusionFilter`:
     - `__init__(self, exclusions: dict)`:
       - `self.app_names` - list of app name patterns (lowercase)
       - `self.window_titles` - list of window title patterns (lowercase)
       - Load from dict with keys "app_names" and "window_titles"

     - `should_exclude(self, window: WindowInfo | None) -> tuple[bool, str | None]`:
       - Returns (should_exclude, matched_pattern)
       - If window is None, return (False, None) - capture is ok
       - Check if any app_name pattern is in window.app_name.lower()
       - Check if any window_title pattern is in window.window_title.lower()
       - Return (True, matched_pattern) if match found
       - Return (False, None) if no match

     - `@classmethod from_yaml(cls, yaml_path: Path) -> ExclusionFilter`:
       - Loads exclusion patterns from YAML file
       - Falls back to empty lists if file not found

2. Update `agent/src/jarvis/monitor/__init__.py` to export WindowMonitor, ExclusionFilter, WindowInfo

Pattern matching should be case-insensitive substring matching (e.g., "1password" matches "1Password 8 - vault").
  </action>
  <verify>
cd /home/sven/Documents/jarvis/agent && python -c "
from jarvis.monitor.window import WindowMonitor, ExclusionFilter, WindowInfo

# Test window monitor
wm = WindowMonitor()
active = wm.get_active_window()
print(f'Active window: {active}')

# Test exclusion filter
exclusions = {
    'app_names': ['1password', 'bitwarden'],
    'window_titles': ['private browsing']
}
ef = ExclusionFilter(exclusions)

# Test with fake window info
fake_pass = WindowInfo('1Password 8', 'Vault - 1Password', True)
fake_browser = WindowInfo('Firefox', 'GitHub - Firefox', True)
fake_private = WindowInfo('Firefox', 'Private Browsing - Firefox', True)

print(f'1Password: exclude={ef.should_exclude(fake_pass)}')
print(f'Normal browser: exclude={ef.should_exclude(fake_browser)}')
print(f'Private browsing: exclude={ef.should_exclude(fake_private)}')
"
  </verify>
  <done>WindowMonitor detects active window, ExclusionFilter correctly identifies apps/titles to exclude</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. IdleDetector can start/stop without errors and tracks activity
2. WindowMonitor returns current active window information
3. ExclusionFilter matches password managers and private browsing patterns
4. Exclusion patterns are case-insensitive
</verification>

<success_criteria>
- Idle detection pauses capture when no input for 5+ minutes (covers part of CAPT-05)
- Window detection identifies active application (required for CAPT-03)
- Exclusion filter blocks password managers and private browsing (covers CAPT-03)
- Default exclusions loaded from YAML configuration
</success_criteria>

<output>
After completion, create `.planning/phases/01-privacy-first-capture-foundation/01-05-SUMMARY.md`
</output>
