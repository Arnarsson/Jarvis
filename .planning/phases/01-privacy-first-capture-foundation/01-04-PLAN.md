---
phase: 01-privacy-first-capture-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - server/src/jarvis_server/db/models.py
  - server/alembic.ini
  - server/alembic/env.py
  - server/alembic/versions/001_initial_schema.py
  - server/src/jarvis_server/storage/__init__.py
  - server/src/jarvis_server/storage/filesystem.py
autonomous: true

must_haves:
  truths:
    - "Capture model stores metadata with filepath reference"
    - "Database migrations can be applied with alembic upgrade"
    - "Files can be stored in date-partitioned directory structure"
  artifacts:
    - path: "server/src/jarvis_server/db/models.py"
      provides: "SQLAlchemy ORM models"
      contains: "class Capture"
    - path: "server/alembic/versions/001_initial_schema.py"
      provides: "Initial database migration"
      contains: "def upgrade"
    - path: "server/src/jarvis_server/storage/filesystem.py"
      provides: "File storage operations"
      contains: "class FileStorage"
  key_links:
    - from: "server/src/jarvis_server/db/models.py"
      to: "sqlalchemy.orm"
      via: "Mapped columns"
      pattern: "Mapped\\["
    - from: "server/src/jarvis_server/storage/filesystem.py"
      to: "aiofiles"
      via: "Async file operations"
      pattern: "aiofiles\\.open"
---

<objective>
Implement database schema and filesystem storage for captures.

Purpose: Establishes the data persistence layer for storing capture metadata in PostgreSQL and image files on disk with date-partitioned organization.
Output: SQLAlchemy models, Alembic migrations, and async filesystem storage module.
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-privacy-first-capture-foundation/01-RESEARCH.md
@.planning/phases/01-privacy-first-capture-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database models and migrations</name>
  <files>
    server/src/jarvis_server/db/models.py
    server/alembic.ini
    server/alembic/env.py
    server/alembic/versions/001_initial_schema.py
  </files>
  <action>
Create SQLAlchemy 2.0 models and Alembic migration:

1. Create `server/src/jarvis_server/db/models.py`:
   - Import from sqlalchemy.orm: DeclarativeBase, Mapped, mapped_column
   - Import from sqlalchemy: String, DateTime, Integer, Text, func
   - Import UUID from uuid, datetime

   - Class `Base(DeclarativeBase)`: pass

   - Class `Capture(Base)`:
     - `__tablename__ = "captures"`
     - `id: Mapped[str]` = mapped_column(String(36), primary_key=True) # UUID as string
     - `filepath: Mapped[str]` = mapped_column(String(500), nullable=False)
     - `timestamp: Mapped[datetime]` = mapped_column(DateTime(timezone=True), nullable=False)
     - `monitor_index: Mapped[int]` = mapped_column(Integer, default=0)
     - `width: Mapped[int]` = mapped_column(Integer, nullable=False)
     - `height: Mapped[int]` = mapped_column(Integer, nullable=False)
     - `file_size: Mapped[int]` = mapped_column(Integer, nullable=False)
     - `ocr_text: Mapped[str | None]` = mapped_column(Text, nullable=True) # For later OCR
     - `created_at: Mapped[datetime]` = mapped_column(DateTime(timezone=True), server_default=func.now())

   - Add index on timestamp for time-range queries

2. Initialize Alembic:
   - Run: `cd server && alembic init alembic`
   - Edit `alembic.ini`: set sqlalchemy.url to use env var: `%(JARVIS_DATABASE_URL)s`
   - Edit `alembic/env.py`:
     - Import Base from jarvis_server.db.models
     - Set target_metadata = Base.metadata
     - Configure for async: use run_async and async engine

3. Create migration `server/alembic/versions/001_initial_schema.py`:
   - Creates captures table with all columns and indexes
   - Use UUID extension if needed (PostgreSQL)

IMPORTANT: Use SQLAlchemy 2.0 mapped_column syntax, NOT Column from 1.x style.
  </action>
  <verify>
cd /home/sven/Documents/jarvis/server && python -c "
from jarvis_server.db.models import Base, Capture
print(f'Tables: {list(Base.metadata.tables.keys())}')
print(f'Capture columns: {[c.name for c in Capture.__table__.columns]}')
"
  </verify>
  <done>Capture model defined with all fields, Alembic configured for async migrations</done>
</task>

<task type="auto">
  <name>Task 2: Filesystem storage module</name>
  <files>
    server/src/jarvis_server/storage/__init__.py
    server/src/jarvis_server/storage/filesystem.py
  </files>
  <action>
Implement async filesystem storage:

1. Create `server/src/jarvis_server/storage/filesystem.py`:
   - Class `FileStorage`:
     - `__init__(self, base_path: Path)`:
       - Stores base storage path
       - Creates base_path if not exists

     - `async def store(self, capture_id: str, data: bytes, timestamp: datetime) -> Path`:
       - Generates path: `{base_path}/{YYYY}/{MM}/{DD}/{capture_id}.jpg`
       - Creates date directories if needed (async os.makedirs equivalent)
       - Writes file using aiofiles
       - Returns full path to stored file

     - `async def retrieve(self, filepath: Path) -> bytes`:
       - Reads and returns file content
       - Raises FileNotFoundError if missing

     - `async def delete(self, filepath: Path) -> bool`:
       - Deletes file if exists
       - Returns True if deleted, False if not found

     - `def get_storage_stats(self) -> dict`:
       - Returns dict with total_files, total_size_mb
       - Can be sync since it's for monitoring only

2. Create `server/src/jarvis_server/storage/__init__.py` exporting FileStorage

Use aiofiles for all file I/O operations. Use pathlib.Path consistently.
Date-partitioned structure enables easy cleanup/archival of old captures.
  </action>
  <verify>
cd /home/sven/Documents/jarvis/server && python -c "
import asyncio
from pathlib import Path
from datetime import datetime
from jarvis_server.storage import FileStorage

async def test():
    fs = FileStorage(Path('/tmp/jarvis-test-storage'))
    test_data = b'test image data'
    path = await fs.store('test-id-123', test_data, datetime.now())
    print(f'Stored at: {path}')
    retrieved = await fs.retrieve(path)
    print(f'Retrieved {len(retrieved)} bytes')
    deleted = await fs.delete(path)
    print(f'Deleted: {deleted}')

asyncio.run(test())
"
  </verify>
  <done>FileStorage can store, retrieve, and delete files with date-partitioned paths</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Capture model has all required fields for metadata storage
2. Alembic can generate and apply migrations
3. FileStorage creates proper date-partitioned directory structure
4. Async file operations work correctly
</verification>

<success_criteria>
- Database schema supports capture metadata (covers data storage aspect of CAPT-06)
- Migrations are version-controlled with Alembic
- File storage uses date-partitioned structure for easy management
- All file I/O is async for non-blocking operation
</success_criteria>

<output>
After completion, create `.planning/phases/01-privacy-first-capture-foundation/01-04-SUMMARY.md`
</output>
