---
phase: 01-privacy-first-capture-foundation
plan: 08
type: execute
wave: 4
depends_on: ["01-03", "01-05", "01-07"]
files_modified:
  - agent/src/jarvis/engine/__init__.py
  - agent/src/jarvis/engine/capture_loop.py
  - agent/src/jarvis/engine/orchestrator.py
autonomous: true

must_haves:
  truths:
    - "Capture loop runs continuously at configured interval"
    - "Capture pauses when idle or excluded app is active"
    - "Captures are queued for upload automatically"
  artifacts:
    - path: "agent/src/jarvis/engine/capture_loop.py"
      provides: "Main capture loop logic"
      contains: "class CaptureLoop"
    - path: "agent/src/jarvis/engine/orchestrator.py"
      provides: "Coordinates all capture components"
      contains: "class CaptureOrchestrator"
  key_links:
    - from: "agent/src/jarvis/engine/capture_loop.py"
      to: "agent/src/jarvis/capture/screenshot.py"
      via: "ScreenCapture usage"
      pattern: "ScreenCapture"
    - from: "agent/src/jarvis/engine/capture_loop.py"
      to: "agent/src/jarvis/monitor/idle.py"
      via: "IdleDetector check"
      pattern: "is_idle"
    - from: "agent/src/jarvis/engine/orchestrator.py"
      to: "agent/src/jarvis/sync/uploader.py"
      via: "Upload integration"
      pattern: "CaptureUploader"
---

<objective>
Integrate all capture components into a unified capture engine.

Purpose: Creates the main capture loop that coordinates screenshot capture, change detection, idle monitoring, exclusion filtering, and upload queuing into a cohesive system.
Output: CaptureOrchestrator that manages the full capture lifecycle.
</objective>

<execution_context>
@/home/sven/.claude/get-shit-done/workflows/execute-plan.md
@/home/sven/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-privacy-first-capture-foundation/01-RESEARCH.md
@.planning/phases/01-privacy-first-capture-foundation/01-03-SUMMARY.md
@.planning/phases/01-privacy-first-capture-foundation/01-05-SUMMARY.md
@.planning/phases/01-privacy-first-capture-foundation/01-07-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Main capture loop</name>
  <files>
    agent/src/jarvis/engine/__init__.py
    agent/src/jarvis/engine/capture_loop.py
  </files>
  <action>
Implement the core capture loop:

1. Create `agent/src/jarvis/engine/capture_loop.py`:
   - Enum `CaptureState`: RUNNING, PAUSED, STOPPED

   - Class `CaptureLoop`:
     - `__init__(self, config: Settings)`:
       - Creates ScreenCapture instance
       - Creates ChangeDetector with config.capture_interval
       - Creates IdleDetector with config.idle_threshold
       - Creates WindowMonitor
       - Creates ExclusionFilter from config exclusions
       - Initializes state = STOPPED
       - Stores callbacks for events

     - `def on_capture(self, callback: Callable[[CaptureResult], None])`:
       - Registers callback for when capture occurs
       - CaptureResult: monitor_index, image, jpeg_bytes, timestamp, reason

     - `def on_skip(self, callback: Callable[[str], None])`:
       - Registers callback for when capture skipped (reason string)

     - `def on_state_change(self, callback: Callable[[CaptureState], None])`:
       - Registers callback for state changes

     - `async def start(self)`:
       - Sets state = RUNNING
       - Starts IdleDetector
       - Enters main loop (see below)

     - `async def _run_loop(self)`:
       - While state == RUNNING:
         1. Check if idle -> skip with reason "user_idle"
         2. Check exclusion filter -> skip with reason "excluded_app: {name}"
         3. For each active monitor:
            - Capture screenshot
            - Check change detection
            - If should_capture: call on_capture callbacks
            - Else: call on_skip with reason
         4. await asyncio.sleep(1.0) # Check interval, not capture interval
            - The change detector handles actual capture timing

     - `def pause(self)`: Sets state = PAUSED
     - `def resume(self)`: Sets state = RUNNING
     - `def stop(self)`: Sets state = STOPPED, stops IdleDetector

2. Create `agent/src/jarvis/engine/__init__.py` exporting CaptureLoop, CaptureState

The loop runs on a 1-second tick but change detector determines if capture happens.
This allows responsive pause/resume while respecting the hybrid trigger logic.
  </action>
  <verify>
cd /home/sven/Documents/jarvis/agent && python -c "
import asyncio
from jarvis.engine.capture_loop import CaptureLoop, CaptureState
from jarvis.config import get_settings

async def test():
    settings = get_settings()
    loop = CaptureLoop(settings)

    captures = []
    loop.on_capture(lambda r: captures.append(r))

    # Run briefly
    async def run_briefly():
        await loop.start()

    task = asyncio.create_task(run_briefly())
    await asyncio.sleep(2)
    loop.stop()
    await asyncio.sleep(0.5)
    task.cancel()

    print(f'Captured {len(captures)} images in 2 seconds')

asyncio.run(test())
"
  </verify>
  <done>CaptureLoop runs, captures screenshots, respects idle and exclusion rules</done>
</task>

<task type="auto">
  <name>Task 2: Capture orchestrator</name>
  <files>
    agent/src/jarvis/engine/orchestrator.py
  </files>
  <action>
Implement the high-level orchestrator:

1. Create `agent/src/jarvis/engine/orchestrator.py`:
   - Class `CaptureOrchestrator`:
     - `__init__(self, config: Settings)`:
       - Creates CaptureLoop
       - Creates UploadQueue (from config.data_dir / "queue.db")
       - Creates CaptureUploader (from config.server_url)
       - Sets up logging with structlog
       - Background upload task reference

     - `async def start(self)`:
       - Wire up CaptureLoop.on_capture to _handle_capture
       - Wire up CaptureLoop.on_skip to _handle_skip (logging)
       - Start background upload task (_upload_worker)
       - Start CaptureLoop

     - `async def _handle_capture(self, result: CaptureResult)`:
       - Save capture to local storage (config.data_dir / "captures" / dated path)
       - Enqueue in UploadQueue with metadata
       - Log capture event

     - `async def _upload_worker(self)`:
       - While running:
         - Get pending items from queue
         - For each item:
           - Try upload
           - On success: mark_completed
           - On failure: mark_failed
         - Sleep 5 seconds between batches

     - `def pause(self)`: Pauses capture loop
     - `def resume(self)`: Resumes capture loop
     - `async def stop(self)`: Stops everything gracefully
     - `def force_sync(self)`: Triggers immediate upload attempt

     - `def get_status(self) -> dict`:
       - Returns current state, queue stats, last capture time

     - Properties: `state`, `is_paused`, `queue_size`

Update `agent/src/jarvis/engine/__init__.py` to export CaptureOrchestrator

This is the main entry point that CLI and tray will use.
  </action>
  <verify>
cd /home/sven/Documents/jarvis/agent && python -c "
import asyncio
from jarvis.engine.orchestrator import CaptureOrchestrator
from jarvis.config import get_settings

async def test():
    settings = get_settings()
    orch = CaptureOrchestrator(settings)

    print(f'Initial status: {orch.get_status()}')

    # Brief run
    task = asyncio.create_task(orch.start())
    await asyncio.sleep(3)

    print(f'After 3s: {orch.get_status()}')

    await orch.stop()
    task.cancel()

asyncio.run(test())
"
  </verify>
  <done>CaptureOrchestrator coordinates capture, queuing, and upload; provides status</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. CaptureLoop respects idle detection and exclusion rules
2. Captures are saved locally and queued for upload
3. Background worker processes upload queue
4. Orchestrator provides unified status interface
</verification>

<success_criteria>
- Continuous capture at configured interval (CAPT-01)
- Change detection skips redundant captures (CAPT-02)
- Exclusion rules are enforced (CAPT-03)
- Idle detection pauses capture (CAPT-05)
- Captures queued for upload (CAPT-06)
</success_criteria>

<output>
After completion, create `.planning/phases/01-privacy-first-capture-foundation/01-08-SUMMARY.md`
</output>
